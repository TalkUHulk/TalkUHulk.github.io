[{"id":"82f698705681b0bacc9c6cad3db6d88e","title":"YOLO-V3学习笔记","content":"YOLO-V3学习笔记\n\n\n\n\n\n\n\n\n知识点来源于论文和网络，仅记录学习\n网络结构Backbone\n整个v3结构没有池化层和全连接层\n输出特征图缩小到输入的1/32。所以，通常都要求输入图片是32的倍数\n\n\n\nDBL:代码中的Darknetconv2d_BN_Leaky，是yolo_v3的基本组件。就是卷积+BN+Leaky relu。resn:n代表数字，有res1，res2, … ,res8等等，表示这个res_block里含有多少个res_unit。concat:张量拼接。将darknet中间层和后面的某一层的上采样进行拼接。拼接的操作和残差层add的操作是不一样的，拼接会扩充张量的维度，而add只是直接相加不会导致张量维度的改变。\nOutputyolo v3输出了3个不同尺度的feature map，如上图所示的y1, y2, y3。借鉴了FPN(feature pyramid networks)，采用多尺度来对不同size的目标进行检测，越精细的grid cell就可以检测出越精细的物体(大分辨率y3更能检测小物体，小分辨率y1更能检测大物体)。\ny1,y2和y3的深度都是255，边长分别为13:26:52。对于COCO类别而言，有80个种类，所以每个box应该对每个种类都输出一个概率。\nyolo v3设定的是每个网格单元预测3个box，所以每个box需要有(x, y, w, h, confidence)五个基本参数，然后还要有80个类别的概率。所以3*(5 + 80) = 255。这个255就是这么来的。v3用上采样的方法来实现这种多尺度的feature map，concat连接的两个张量是具有一样尺度的(两处拼接分别是26x26尺度拼接和52x52尺度拼接，通过(2, 2)上采样来保证concat拼接的张量尺度相同)。作者并没有像SSD那样直接采用backbone中间层的处理结果作为feature map的输出，而是和后面网络层的上采样结果进行一个拼接之后的处理结果作为feature map。\nBounding Box在Yolov1中，网络直接回归检测框的宽、高，这样效果有限。所以在Yolov2中，改为了回归基于先验框的变化值，这样网络的学习难度降低，整体精度提升不小。Yolov3沿用了Yolov2中关于先验框的技巧，并且使用k-means对数据集中的标签框进行聚类，得到类别中心点的9个框，作为先验框。在COCO数据集中（原始图片全部resize为416 × 416），九个框分别是 (10×13)，(16×30)，(33×23)，(30×61)，(62×45)，(59× 119)， (116 × 90)， (156 × 198)，(373 × 326) ，顺序为w × h。\nfeature map中的每一个cell都会预测3个边界框（bounding box） ，每个bounding box都会预测三个东西：\n\n每个框的位置（4个值，中心坐标tx和ty，框的高度bh和宽度bw）\n一个objectness prediction \nN个类别\n\n三个output，每个对应的感受野不同，32倍降采样的感受野最大，适合检测大的目标，所以在输入为416×416时，每个cell的三个anchor box为(116 ,90); (156 ,198); (373 ,326)。16倍适合一般大小的物体，anchor box为(30,61); (62,45); (59,119)。8倍的感受野最小，适合检测小目标，因此anchor box为(10,13); (16,30); (33,23)。所以当输入为416×416时，实际总共有（52×52+26×26+13×13）×3=10647个proposal box。\n\n\n\n特征图\n13x13\n26x26\n52x52\n\n\n\n感受野\n大\n中\n小\n\n\n先验框\n(116 ,90)(156 ,198)(373 ,326)\n(30,61) (62,45)(59,119)\n(10,13)(16,30)(33,23)\n\n\n\n\n\n\n\n\n\n\n\n\n这里注意bounding box 与anchor box的区别：Bounding box它输出的是框的位置（中心坐标与宽高），confidence以及N个类别。anchor box只是一个尺度即只有宽高。\nOutput DecodeBounding box decode如上一节所说，v2开始，回归基于先验框的变化值，因此可以通过以下公式解码检测框的x，y，w，h.\n\n\n\n\n\n如上图，$\\sigma(t_x)$、$\\sigma(t_y)$是基于矩形框中心点左上角格点坐标的偏移量, $\\sigma$是激活函数，论文中作者使用sigmoid,  $p_w, p_h$是先验框的宽、高，通过上述公式，计算出实际预测框的宽高 $b_w, b_h$.\n\n\n\n\n\n\n\n\n\n得到对应的$b_w, b_h$后, 还需要乘以特征图对应的的采样率(32,16,8)，得到真实的检测框x,y\nobjectness score decode物体的检测置信度，在Yolo设计中非常重要，关系到算法的检测正确率与召回率。置信度在输出85维中占固定一位，由sigmoid函数解码即可，解码之后数值区间在[0，1]中。\nlogistic回归用于对anchor包围的部分进行一个目标性评分(objectness score)，即这块位置是目标的可能性有多大。这一步是在predict之前进行的，可以去掉不必要anchor，可以减少计算量。作者在论文种的描述如下:\n\n\n\n\n\n\n\n\n\nIf the bounding box prior is not the best but does overlap a ground truth object by more than some threshold we ignore the prediction, following[17]. We use the threshold of 0.5. Unlike [17] our system only assigns one bounding box prior for each ground truth object.\n如果模板框不是最佳的即使它超过我们设定的阈值，我们还是不会对它进行predict。不同于faster R-CNN的是，yolo_v3只会对1个prior进行操作，也就是那个最佳prior。而logistic回归就是用来从9个anchor priors中找到objectness score(目标存在可能性得分)最高的那一个。logistic回归就是用曲线对prior相对于 objectness score映射关系的线性建模。\nClass Prediction decodeCOCO数据集有80个类别，所以类别数在85维输出中占了80维，每一维独立代表一个类别的置信度。使用sigmoid激活函数替代了Yolov2中的softmax，取消了类别之间的互斥，可以使网络更加灵活。\n总结\n9个anchor会被三个输出张量平分的。根据大中小三种size各自取自己的anchor。\n\n作者使用了logistic回归来对每个anchor包围的内容进行了一个目标性评分(objectness score)。根据目标性评分来选择anchor prior进行predict，而不是所有anchor prior都会有输出。\n\n\n训练策略\n\n\n\n\n\n\n\n\nYOLOv3 predicts an objectness score for each bounding box using logistic regression. This should be 1 if the bounding box prior overlaps a ground truth object by more than any other bounding box prior. If the bounding box prior is not the best but does overlap a ground truth object by more than some threshold we ignore the prediction, following [17]. We use the threshold of .5. Unlike [17] our system only assigns one bounding box prior for each ground truth object. If a bounding box prior is not assigned to a ground truth object it incurs no loss for coordinate or class predictions, only objectness.\n预测框一共分为三种情况：正例（positive）、负例（negative）、忽略样例（ignore）。\n正例：任取一个ground truth，与4032个框全部计算IOU，IOU最大的预测框，即为正例。并且一个预测框，只能分配给一个ground truth。例如第一个ground truth已经匹配了一个正例检测框，那么下一个ground truth，就在余下的4031个检测框中，寻找IOU最大的检测框作为正例。ground truth的先后顺序可忽略。正例产生置信度loss、检测框loss、类别loss。预测框为对应的ground truth box标签（需要反向编码，使用真实的x、y、w、h计算出  ）；类别标签对应类别为1，其余为0；置信度标签为1。\n忽略样例：正例除外，与任意一个ground truth的IOU大于阈值（论文中使用0.5），则为忽略样例。忽略样例不产生任何loss。\n负例：正例除外（与ground truth计算后IOU最大的检测框，但是IOU小于阈值，仍为正例），与全部ground truth的IOU都小于阈值（0.5），则为负例。负例只有置信度产生loss，置信度标签为0。\nLossYolov3 Loss为三个特征图Loss之和：\n$Loss = Loss_n1 + Loss_n2 + Loss_n3$\n\n\n\n\n$\\lambda$为权重常数，控制检测框Loss、obj置信度Loss、noobj置信度Loss之间的比例，通常负例的个数是正例的几十倍以上，可以通过权重超参控制检测效果;\n$1^{obj}{ij}$ 若是正例则输出1，否则为0；$1^{noobj}{ij}$ ,若是负例则输出1，否则为0；忽略样例都输出0;\nx、y、w、h使用MSE作为损失函数，也可以使用smooth L1 loss（出自Faster R-CNN）作为损失函数。smooth L1可以使训练更加平滑。置信度、类别标签由于是0，1二分类，所以使用交叉熵作为损失函数。\n\n其他\nground truth为什么不按照中心点分配对应的预测box？\n\n\n\n\n\n\n\n\n\n在Yolov3的训练策略中，不再像Yolov1那样，每个cell负责中心落在该cell中的ground truth。原因是Yolov3一共产生3个特征图，3个特征图上的cell，中心是有重合的。训练时，可能最契合的是特征图1的第3个box，但是推理的时候特征图2的第1个box置信度最高。所以Yolov3的训练，不再按照ground truth中心点，严格分配指定cell，而是根据预测值寻找IOU最大的预测框作为正例。\n\n为什么有忽略样例？\n\n忽略样例是Yolov3中的点睛之笔。由于Yolov3使用了多尺度特征图，不同尺度的特征图之间会有重合检测部分。比如有一个真实物体，在训练时被分配到的检测框是特征图1的第三个box，IOU达0.98，此时恰好特征图2的第一个box与该ground truth的IOU达0.95，也检测到了该ground truth，如果此时给其置信度强行打0的标签，网络学习效果会不理想。\n本身正负样本比例就不均衡（负例&gt;正例），如果强行标为0，会使不均衡更严重。\n\n\n\n","slug":"YOLO-V3学习笔记","date":"2021-08-30T11:59:09.000Z","categories_index":"","tags_index":"detection","author_index":"Hulk Wang"},{"id":"2a4b32b81021e06bffb6e540079ceefc","title":"hexo+github 搭建个人博客","content":"hexo+github搭建个人博客\n\n\n\n\n\n\n\n\n搭建环境:macOs 11.4环境依赖:\n\ngit\nnpm\nnode\nhexo\n\nhexo安装\n安装nodebrew install node\n安装hexonpm install -g hexo-cli\n查看hexo版本hexo -v![version](/images/node_version.jpg ‘’version’’)\n\n建站\n\n\n\n\n\n\n\n\n安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件\n\n初始化hexo框架hexo init &lt;folder&gt;\n移动到目标目录cd &lt;folder&gt;\n安装依赖组件npm install \n生成静态文件hexo g\n开启本地服务器hexo s\n\n\n\n\n\n\n\n\n\n\n在浏览器中输入 http://localhost:4000 回车就可以预览效果了\n更换主题\n\n\n\n\n\n\n\n\n此时博客是hexo默认主题，比较普通，这里推荐一个主题：Aurora\n安装教程\n效果预览\n配置github\n建立respositoryrepository名称为username.github.io\n\n修改配置文件\n\n\n\n\n\n\n\n\n\n_config.yml文件\n\n\ndeploy:  \n\ttype: git \n\trepository: https:&#x2F;&#x2F;github.com&#x2F;username&#x2F;username.github.io.git\n\tbranch: master\n\n安装一个部署插件npm install hexo-deployer-git --save\n\n重新生成部署hexo g -d\n\n\n\n\n\n\n\n\n\n\n\n此时可通过 https://username.github.io 访问博客\n配置个性域名\n\n\n\n\n\n\n\n\n这里我购买了腾讯云的域名: hulk.show\n\n配置域名 \n\n\n\n\n\n\n\n\n\n进入域名管理界面，选择解析，添加两条解析：\n\n配置git\n\n\n\n\n\n\n\n\n\n你的项目-&gt;Setting-&gt;Pages-&gt;Custom domain,添加你的域名：\n\n\n\n\n\n\n\n\n\n\n\n可能需要等几分钟,即可通过购买的域名访问博客：www.hulk.show\n","slug":"hexo-github-搭建个人博客","date":"2021-08-29T10:50:28.000Z","categories_index":"","tags_index":"config","author_index":"Hulk Wang"}]