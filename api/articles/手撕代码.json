{"title":"æ‰‹æ’•ä»£ç ","uid":"66e6fbbf30cdfd5fb293d5ee17ed3935","slug":"æ‰‹æ’•ä»£ç ","date":"2021-10-19T03:41:08.000Z","updated":"2021-10-28T09:23:01.142Z","comments":true,"path":"api/articles/æ‰‹æ’•ä»£ç .json","keywords":null,"cover":[],"content":"<h4 id=\"iou\">1. IOU</h4>\n<h5 id=\"python\">python</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">def bb_intersection_over_union(boxA, boxB):\n    boxA &#x3D; [int(x) for x in boxA]\n    boxB &#x3D; [int(x) for x in boxB]\n\n    xA &#x3D; max(boxA[0], boxB[0])\n    yA &#x3D; max(boxA[1], boxB[1])\n    xB &#x3D; min(boxA[2], boxB[2])\n    yB &#x3D; min(boxA[3], boxB[3])\n\n    interArea &#x3D; max(0, xB - xA + 1) * max(0, yB - yA + 1)\n\n    boxAArea &#x3D; (boxA[2] - boxA[0] + 1) * (boxA[3] - boxA[1] + 1)\n    boxBArea &#x3D; (boxB[2] - boxB[0] + 1) * (boxB[3] - boxB[1] + 1)\n    \n    iou &#x3D; interArea &#x2F; float(boxAArea + boxBArea - interArea)\n\n    return iou<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"c\">c++</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\ntypedef struct Bbox\n&#123;\n    int x1;\n    int y1;\n    int x2;\n    int y2;\n    float score;\n&#125;Bbox;\n\nfloat iou(Bbox box1,Bbox box2)\n&#123;\n    max_x &#x3D; max(box1.x1,box2.x1);  &#x2F;&#x2F; æ‰¾å‡ºå·¦ä¸Šè§’åæ ‡å“ªä¸ªå¤§\n    min_x &#x3D; min(box1.x2,box2.x2);  &#x2F;&#x2F; æ‰¾å‡ºå³ä¸Šè§’åæ ‡å“ªä¸ªå°\n    max_y &#x3D; max(box1.y1,box2.y1);\n    min_y &#x3D; min(box1.y2,box2.y2);\n    if(min_x&lt;&#x3D;max_x || min_y&lt;&#x3D;max_y) &#x2F;&#x2F; å¦‚æœæ²¡æœ‰é‡å \n        return 0;\n    float over_area &#x3D; (min_x - max_x) * (min_y - max_y);  &#x2F;&#x2F; è®¡ç®—é‡å é¢ç§¯\n    float area_a &#x3D; (box1.x2 - boxa.x1) * (box1.y2 - boxa.y1);\n    float area_b &#x3D; (box2.x2 - boxb.x1) * (box2.y2 - boxb.y1);\n    float iou &#x3D; over_area &#x2F; (area_a + area_b - over_area);\n    return iou;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"nms\">2. NMS</h4>\n<h5 id=\"python-1\">python</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">def nms(det, thresh):\n    x1 &#x3D; det[..., 0]\n    y1 &#x3D; det[..., 1]\n    x2 &#x3D; det[..., 2]\n    y2 &#x3D; det[..., 3]\n    scores &#x3D; det[..., 4]\n    area &#x3D; (x2 - x1 + 1) * (y2 - y1 + 1)\n    order &#x3D; np.argsort(scores)[::-1]  # Returns the indices that would sort an array.\n    keep &#x3D; []\n    while order.size &gt; 0:\n        i &#x3D; order[0]\n        keep.append(i)\n        xx1 &#x3D; np.maximum(x1[i], x1[order[1:]])\n        yy1 &#x3D; np.maximum(y1[i], y1[order[1:]])\n        xx2 &#x3D; np.minimum(x2[i], x2[order[1:]])\n        yy2 &#x3D; np.minimum(x2[i], x2[order[1:]])\n        w &#x3D; np.maximum(0, xx2 - xx1 + 1)\n        h &#x3D; np.maximum(0, yy2 - yy1 + 1)\n        inter &#x3D; w * h\n        union &#x3D; area[i] + area[order[1:]] - inter\n        iou &#x3D; inter &#x2F; union\n        next_i &#x3D; np.where(iou &lt;&#x3D; thresh)[0]  # åªæœ‰æ¡ä»¶ (condition)ï¼Œæ²¡æœ‰xå’Œyï¼Œåˆ™è¾“å‡ºæ»¡è¶³æ¡ä»¶ (å³é0) å…ƒç´ çš„åæ ‡\n        order &#x3D; order[next_i + 1]\n    return keep<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"c-1\">c++</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;*\n  å°†bbxæŒ‰ç…§confidenceä»é«˜åˆ°ä½æ’åº\n*&#x2F;\nbool sort_score(Bbox box1,Bbox box2)\n&#123;\n    return (box1.score &gt; box2.score);\n&#125;\n&#x2F;*\n(1) è·å–å½“å‰ç›®æ ‡ç±»åˆ«ä¸‹æ‰€æœ‰bbxçš„ä¿¡æ¯\n(2) å°†bbxæŒ‰ç…§confidenceä»é«˜åˆ°ä½æ’åº,å¹¶è®°å½•å½“å‰confidenceæœ€å¤§çš„bbx\n(3) è®¡ç®—æœ€å¤§confidenceå¯¹åº”çš„bbxä¸å‰©ä¸‹æ‰€æœ‰çš„bbxçš„IOU,ç§»é™¤æ‰€æœ‰å¤§äºIOUé˜ˆå€¼çš„bbx\n(4) å¯¹å‰©ä¸‹çš„bbxï¼Œå¾ªç¯æ‰§è¡Œ(2)å’Œ(3)ç›´åˆ°æ‰€æœ‰çš„bbxå‡æ»¡è¶³è¦æ±‚ï¼ˆå³ä¸èƒ½å†ç§»é™¤bbxï¼‰\n*&#x2F;\nvector&lt;Bbox&gt; nms(vector&lt;Bbox&gt;&amp;vec_boxs, float threshold)\n&#123;\n    vector&lt;Bbox&gt;  res;\n    while(vec_boxs.size() &gt; 0)\n    &#123;\n        sort(vec_boxs.begin(),vec_boxs.end(),cmp);\n        res.push_back(vec_boxs[0]);\n        for(int i &#x3D;0;i &lt;vec_boxs.size()-1;i++)\n        &#123;\n            float iou_value &#x3D;iou(vec_boxs[0],vec_boxs[i+1]);\n            if (iou_value &gt;threshold)\n            &#123;\n                vec_boxs.erase(vec_boxs[i+1]);\n            &#125;\n        &#125;\n        vec_boxs.erase(vec_boxs[0]);  &#x2F;&#x2F; res å·²ç»ä¿å­˜ï¼Œæ‰€ä»¥å¯ä»¥å°†æœ€å¤§çš„åˆ é™¤äº†\n \n    &#125;\n    return res;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"å·ç§¯\">3. å·ç§¯</h4>\n<h5 id=\"python-2\">python</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">def conv_naive(x, c_out, ksize&#x3D;3, padding&#x3D;0, stride&#x3D;1):\n    b, c_in, h, w &#x3D; x.shape\n    kernel &#x3D; np.random.rand(c_out, c_in, ksize, ksize)\n    out_height &#x3D; (h - ksize + 2 * padding) &#x2F;&#x2F; stride + 1\n    out_width &#x3D; (w - ksize + 2 * padding) &#x2F;&#x2F; stride + 1\n\n    out_x &#x3D; np.random.rand(b, c_out, out_height,  out_width)\n    if padding &gt; 0:\n        pad_x &#x3D; np.zeros((b, c_in, h + 2 * padding, w + 2 * padding))\n        pad_x[..., padding:-padding, padding:-padding] &#x3D; x\n    else:\n        pad_x &#x3D; x\n\n    for y in range(out_height):\n        for x in range(out_width):\n            roi &#x3D; pad_x[..., y * stride:y * stride + ksize, x * stride: x * stride + ksize]\n            conv &#x3D; np.tile(np.expand_dims(roi, axis&#x3D;1), (1, c_out, 1, 1, 1)) * kernel\n            # conv &#x3D; np.repeat(np.expand_dims(roi, axis&#x3D;1), axis&#x3D;1, repeats&#x3D;c_out) * kernel\n            out_x[..., y, x] &#x3D; np.squeeze(np.sum(conv, axis&#x3D;(2, 3, 4), keepdims&#x3D;True), axis&#x3D;(2, 3, 4))\n\n    return out_x<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"c-2\">c++</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;äºŒç»´å·ç§¯çš„å®ç°\n#include&lt;cassert&gt;\n#include&lt;vector&gt;\n\n\nvoid conv2(int** filter, int **mat, int** res, const int filter_rows, const int filter_cols, const int mat_rows, const int mat_cols);&#x2F;&#x2F;æŒ‡é’ˆæ•°ç»„ç‰ˆæœ¬\nstd::vector&lt;std::vector&lt;int&gt; &gt; conv2(std::vector&lt;std::vector&lt;int&gt; &gt; filter, std::vector&lt;std::vector&lt;int&gt; &gt; mat);&#x2F;&#x2F;å‘é‡ç‰ˆæœ¬\n\n\nint main(void)\n&#123;\n    return 0;\n&#125;&#x2F;&#x2F;main\n\nvoid conv2(int** filter, int **mat, int** res, const int filter_rows, const int filter_cols, const int mat_rows, const int mat_cols)\n&#123;\n    assert(filter_cols &lt; mat_cols &amp;&amp; filter_rows &lt; mat_rows);\n    for(int i &#x3D; 0; i &lt; mat_rows - 1; ++i)\n        for (int j &#x3D; 0; j &lt; mat_cols - 1; ++j)\n        &#123;\n            int tmp &#x3D; 0;\n            for (int m &#x3D; 0; m &lt; filter_rows; ++m)\n                for (int n &#x3D; 0; n &lt; filter_cols; ++n)\n                    if(0 &lt;&#x3D; i -m  &amp;&amp; i - m &lt; mat_rows &amp;&amp; 0 &lt;&#x3D; j - n &amp;&amp; j - n &lt; mat_cols)\n                        tmp +&#x3D; filter[m][n] * mat[i - m][j - n];&#x2F;&#x2F;å·ç§¯å…¬å¼\n\n            res[i][j] &#x3D; tmp;\n        &#125;\n&#125;\n\nstd::vector&lt;std::vector&lt;int&gt; &gt; conv2(std::vector&lt;std::vector&lt;int&gt; &gt; filter, std::vector&lt;std::vector&lt;int&gt; &gt; mat )&#x2F;&#x2F;å‘é‡ç‰ˆæœ¬\n&#123;\n    const int filter_rows &#x3D; filter.size();\n    const int filter_cols &#x3D; filter[0].size();\n\n    const int mat_rows &#x3D; mat.size();\n    const int mat_cols &#x3D; mat[0].size();\n\n    assert(filter_cols &lt; mat_cols &amp;&amp; filter_rows &lt; mat_rows);\n    std::vector&lt;std::vector&lt;int&gt; &gt; res(mat_rows, std::vector&lt;int&gt;(mat_cols, 0));\n\n    for (int i &#x3D; 0; i &lt; mat_rows - 1; ++i)\n        for (int j &#x3D; 0; j &lt; mat_cols - 1; ++j)\n        &#123;\n            int tmp &#x3D; 0;\n            for (int m &#x3D; 0; m &lt; filter_rows; ++m)\n                for (int n &#x3D; 0; n &lt; filter_cols; ++n)\n                    if (0 &lt;&#x3D; i - m &amp;&amp; i - m &lt; mat_rows &amp;&amp; 0 &lt;&#x3D; j - n &amp;&amp; j - n &lt; mat_cols)\n                        tmp +&#x3D; filter[m][n] * mat[i - m][j - n];&#x2F;&#x2F;å·ç§¯å…¬å¼\n\n            res[i][j] &#x3D; tmp;\n        &#125;\n    return res;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"pooling\">4. Pooling</h4>\n<h5 id=\"maxpooling\">maxpooling</h5>\n<h6 id=\"ç‰ˆæœ¬1ç®€å•ç‰ˆ\">ç‰ˆæœ¬1(ç®€å•ç‰ˆ)</h6>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">def max_pooling(x, kernel_size&#x3D;2, stride&#x3D;2):\n    b, c_in, h, w &#x3D; x.shape\n    ow &#x3D; (w - kernel_size) &#x2F;&#x2F; stride + 1\n    oh &#x3D; (h - kernel_size) &#x2F;&#x2F; stride + 1\n\n    out &#x3D; np.zeros([b, c_in, oh, ow])\n    x_input &#x3D; x\n    for y in range(oh):\n        for x in range(ow):\n            roi &#x3D; x_input[..., y * stride: y * stride + kernel_size, x * stride: x * stride + kernel_size]\n            max_val &#x3D; np.squeeze(np.max(roi, axis&#x3D;(2, 3), keepdims&#x3D;True), axis&#x3D;(2, 3))\n            out[..., y, x] &#x3D; max_val\n    return out<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h6 id=\"ç‰ˆæœ¬2åå‘ä¼ æ’­\">ç‰ˆæœ¬2(åå‘ä¼ æ’­)</h6>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import numpy as np\nimport torch\nclass MaxPooling2D:\n    def __init__(self, kernel_size&#x3D;(2, 2), stride&#x3D;2):\n        self.kernel_size &#x3D; kernel_size\n        self.w_height &#x3D; kernel_size[0]\n        self.w_width &#x3D; kernel_size[1]\n\n        self.stride &#x3D; stride\n\n        self.x &#x3D; None\n        self.in_height &#x3D; None\n        self.in_width &#x3D; None\n\n        self.out_height &#x3D; None\n        self.out_width &#x3D; None\n\n        self.arg_max &#x3D; None\n\n    def __call__(self, x):\n        self.x &#x3D; x\n        self.in_height &#x3D; np.shape(x)[0]\n        self.in_width &#x3D; np.shape(x)[1]\n\n        self.out_height &#x3D; int((self.in_height - self.w_height) &#x2F; self.stride) + 1\n        self.out_width &#x3D; int((self.in_width - self.w_width) &#x2F; self.stride) + 1\n\n        out &#x3D; np.zeros((self.out_height, self.out_width))\n        self.arg_max &#x3D; np.zeros_like(out, dtype&#x3D;np.int32)\n\n        for i in range(self.out_height):\n            for j in range(self.out_width):\n                start_i &#x3D; i * self.stride\n                start_j &#x3D; j * self.stride\n                end_i &#x3D; start_i + self.w_height\n                end_j &#x3D; start_j + self.w_width\n                out[i, j] &#x3D; np.max(x[start_i: end_i, start_j: end_j])\n                self.arg_max[i, j] &#x3D; np.argmax(x[start_i: end_i, start_j: end_j])\n        self.arg_max &#x3D; self.arg_max\n        return out\n\n    def backward(self, d_loss):\n        dx &#x3D; np.zeros_like(self.x)\n        for i in range(self.out_height):\n            for j in range(self.out_width):\n                start_i &#x3D; i * self.stride\n                start_j &#x3D; j * self.stride\n                end_i &#x3D; start_i + self.w_height\n                end_j &#x3D; start_j + self.w_width\n                index &#x3D; np.unravel_index(self.arg_max[i, j], self.kernel_size)\n                dx[start_i:end_i, start_j:end_j][index] &#x3D; d_loss[i, j] #\n        return dx<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>test</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">np.set_printoptions(precision&#x3D;8, suppress&#x3D;True, linewidth&#x3D;120)\nx_numpy &#x3D; np.random.random((1, 1, 6, 9))\nx_tensor &#x3D; torch.tensor(x_numpy, requires_grad&#x3D;True)\n\nmax_pool_tensor &#x3D; torch.nn.MaxPool2d((2, 2), 2)\nmax_pool_numpy &#x3D; MaxPooling2D((2, 2), stride&#x3D;2)\n\nout_numpy &#x3D; max_pool_numpy(x_numpy[0, 0])\nout_tensor &#x3D; max_pool_tensor(x_tensor)\n\nd_loss_numpy &#x3D; np.random.random(out_tensor.shape)\nd_loss_tensor &#x3D; torch.tensor(d_loss_numpy, requires_grad&#x3D;True)\nout_tensor.backward(d_loss_tensor)\n\ndx_numpy &#x3D; max_pool_numpy.backward(d_loss_numpy[0, 0])\ndx_tensor &#x3D; x_tensor.grad\n# print(&#39;input \\n&#39;, x_numpy)\nprint(&quot;out_numpy \\n&quot;, out_numpy)\nprint(&quot;out_tensor \\n&quot;, out_tensor.data.numpy())\n\nprint(&quot;dx_numpy \\n&quot;, dx_numpy)\nprint(&quot;dx_tensor \\n&quot;, dx_tensor.data.numpy())<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">def pooling(feature_map, size&#x3D;2, stride&#x3D;2):\n    channel&#x3D;feature_map.shape[0]\n    height&#x3D;feature_map.shape[1]\n    width&#x3D;feature_map.shape[2]\n    padding_height&#x3D;np.uint16(round((height-size+1)&#x2F;stride))\n    padding_width&#x3D;np.uint16(round((width-size+1)&#x2F;stride))\n    print(padding_height,padding_width)\n\n    pool_out &#x3D; np.zeros((channel,padding_height,padding_width),dtype&#x3D;np.uint8)\n    \n    for map_num in range(channel):  \n        out_height &#x3D; 0  \n        for r in np.arange(0,height, stride):  \n            out_width &#x3D; 0  \n            for c in np.arange(0, width, stride):  \n                pool_out[map_num,out_height, out_width] &#x3D; np.max(feature_map[map_num,r:r+size,c:c+size])  \n                out_width&#x3D;out_width+1\n            out_height&#x3D;out_height+1\n    return pool_out<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"avg-pooling\">avg-pooling</h5>\n<h6 id=\"ç‰ˆæœ¬1ç®€å•ç‰ˆ-1\">ç‰ˆæœ¬1(ç®€å•ç‰ˆ)</h6>\n<p>def avg_pooling(x, kernel_size=2, stride=2): b, c_in, h, w = x.shape ow = (w - kernel_size) // stride + 1 oh = (h - kernel_size) // stride + 1</p>\n<pre><code>out = np.zeros([b, c_in, oh, ow])\nx_input = x\nfor y in range(oh):\n    for x in range(ow):\n        roi = x_input[..., y * stride: y * stride + kernel_size, x * stride: x * stride + kernel_size]\n        max_val = np.average(roi, axis=(2, 3))\n        out[..., y, x] = max_val\nreturn out</code></pre>\n<h6 id=\"ç‰ˆæœ¬2åå‘ä¼ æ’­-1\">ç‰ˆæœ¬2(åå‘ä¼ æ’­)</h6>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import numpy as np\nimport torch\n\nclass AvgPooling2D:\n    def __init__(self, kernel_size&#x3D;(2, 2), stride&#x3D;2):\n        self.stride &#x3D; stride\n        self.kernel_size &#x3D; kernel_size\n        self.w_height &#x3D; kernel_size[0]\n        self.w_width &#x3D; kernel_size[1]\n\n    def __call__(self, x):\n        self.x &#x3D; x\n        self.in_height &#x3D; x.shape[0]\n        self.in_width &#x3D; x.shape[1]\n\n        self.out_height &#x3D; int((self.in_height - self.w_height) &#x2F; self.stride) + 1\n        self.out_width &#x3D; int((self.in_width - self.w_width) &#x2F; self.stride) + 1\n        out &#x3D; np.zeros((self.out_height, self.out_width))\n\n        for i in range(self.out_height):\n            for j in range(self.out_width):\n                start_i &#x3D; i * self.stride\n                start_j &#x3D; j * self.stride\n                end_i &#x3D; start_i + self.w_height\n                end_j &#x3D; start_j + self.w_width\n                out[i, j] &#x3D; np.mean(x[start_i: end_i, start_j: end_j])\n        return out\n\n    def backward(self, d_loss):\n        dx &#x3D; np.zeros_like(self.x)\n\n        for i in range(self.out_height):\n            for j in range(self.out_width):\n                start_i &#x3D; i * self.stride\n                start_j &#x3D; j * self.stride\n                end_i &#x3D; start_i + self.w_height\n                end_j &#x3D; start_j + self.w_width\n                dx[start_i: end_i, start_j: end_j] &#x3D; d_loss[i, j] &#x2F; (self.w_width * self.w_height)\n        return dx\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>test</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">np.set_printoptions(precision&#x3D;8, suppress&#x3D;True, linewidth&#x3D;120)\nx_numpy &#x3D; np.random.random((1, 1, 6, 9))\nx_tensor &#x3D; torch.tensor(x_numpy, requires_grad&#x3D;True)\n\navg_pool_tensor &#x3D; torch.nn.AvgPool2d((2, 2), 2)\navg_pool_numpy &#x3D; AvgPooling2D((2, 2), stride&#x3D;2)\n\nout_numpy &#x3D; avg_pool_numpy(x_numpy[0, 0])\nout_tensor &#x3D; avg_pool_tensor(x_tensor)\n\nd_loss_numpy &#x3D; np.random.random(out_tensor.shape)\nd_loss_tensor &#x3D; torch.tensor(d_loss_numpy, requires_grad&#x3D;True)\nout_tensor.backward(d_loss_tensor)\n\ndx_numpy &#x3D; avg_pool_numpy.backward(d_loss_numpy[0, 0])\ndx_tensor &#x3D; x_tensor.grad\n# print(&#39;input \\n&#39;, x_numpy)\nprint(&quot;out_numpy \\n&quot;, out_numpy)\nprint(&quot;out_tensor \\n&quot;, out_tensor.data.numpy())\n\nprint(&quot;dx_numpy \\n&quot;, dx_numpy)\nprint(&quot;dx_tensor \\n&quot;, dx_tensor.data.numpy())<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"map\">5. mAP</h4>\n<h5 id=\"python-3\">python</h5>\n<h5 id=\"c-3\">c++</h5>\n<h4 id=\"softnms\">6. softnms</h4>\n<h5 id=\"python-4\">python</h5>\n<h6 id=\"ç‰ˆæœ¬1\">ç‰ˆæœ¬1</h6>\n<h1 id=\"soft_nmsæ“ä½œè¿™é‡Œå‡è®¾boxesæ˜¯æ— åºæœªæŒ‰scoreåšé™åºçš„æ‰€ä»¥æ¯è½®soft_nmsè¿­ä»£éƒ½éœ€è¦ç±»ä¼¼å†’æ³¡æ’åºæ“ä½œé€‰æ‹©å½“å‰top-1-bboxåšnms\">soft_nmsæ“ä½œï¼Œè¿™é‡Œå‡è®¾boxesæ˜¯æ— åº(æœªæŒ‰scoreåšé™åº)çš„ï¼Œæ‰€ä»¥æ¯è½®soft_nmsè¿­ä»£éƒ½éœ€è¦ç±»ä¼¼å†’æ³¡æ’åºæ“ä½œï¼Œé€‰æ‹©å½“å‰top-1 bboxåšNMS</h1>\n<h1 id=\"ntè®¡ç®—iouçš„é˜ˆå€¼iou-ntå¯¹åº”bboxçš„scoreæƒé‡å°±è¦é™ä½\">Ntï¼šè®¡ç®—IoUçš„é˜ˆå€¼ï¼ŒIoU &gt; Ntï¼Œå¯¹åº”bboxçš„scoreæƒé‡å°±è¦é™ä½</h1>\n<h1 id=\"thresholdé™æƒåé€šè¿‡thresholdè¿›ä¸€æ­¥å‰”é™¤ä½æƒé‡bbox\">thresholdï¼šé™æƒåé€šè¿‡thresholdè¿›ä¸€æ­¥å‰”é™¤ä½æƒé‡bbox</h1>\n<p>def cpu_soft_nms(boxes, sigma=0.5, Nt=0.3, threshold=0.001, method=0): N = boxes.shape[0] for i in range(N): maxscore = boxes[i, 4] # è·å–å½“å‰indexä¸‹çš„bbox maxpos = i</p>\n<pre><code>    tx1 = boxes[i, 0]\n    ty1 = boxes[i, 1]\n    tx2 = boxes[i, 2]\n    ty2 = boxes[i, 3]\n    ts = boxes[i, 4]\n\n    pos = i + 1  # ä¸‹é¢æ“ä½œå°±å¾ˆå¸¸è§„äº†ï¼Œæ‰¾åˆ°å½“å‰index iä¹‹åæ‰€æœ‰bboxesä¸­ï¼Œscoreæœ€å¤§çš„bboxï¼Œå¹¶å°†ä¹‹èµ‹å€¼ç»™maxscoreã€maxpos\n    while pos &lt; N:\n        if maxscore &lt; boxes[pos, 4]:\n            maxscore = boxes[pos, 4]\n            maxpos = pos\n        pos = pos + 1\n\n    # ä¸‹é¢æ“ä½œæ›´ç®€å•ï¼Œæƒ³æƒ³æˆ‘ä»¬æœ€å¼€å§‹å­¦Cè¯­è¨€ï¼Œaã€bä¸¤å˜é‡å¦‚ä½•äº¤æ¢\n    # add max box as a detection\n    boxes[i, 0] = boxes[maxpos, 0]  # maxposå†…çš„ä¿¡æ¯ï¼Œæ”¾åˆ°index iå¤„ï¼Œä¹Ÿæ˜¯å½“å‰éœ€è¦å¤„ç†çš„bbox\n    boxes[i, 1] = boxes[maxpos, 1]\n    boxes[i, 2] = boxes[maxpos, 2]\n    boxes[i, 3] = boxes[maxpos, 3]\n    boxes[i, 4] = boxes[maxpos, 4]\n\n    # swap ith box with position of max box\n    boxes[maxpos, 0] = tx1  # åˆ«å¿˜äº†tx1ä¸­å¯æ˜¯ä¿å­˜äº†boxes[i,0]å¤‡ä»½çš„\n    boxes[maxpos, 1] = ty1\n    boxes[maxpos, 2] = tx2\n    boxes[maxpos, 3] = ty2\n    boxes[maxpos, 4] = ts\n\n    tx1 = boxes[i, 0]  # æ­¤æ—¶tx1å°±ä¿å­˜çš„maxposä½ç½®çš„bboxä¿¡æ¯äº†\n    ty1 = boxes[i, 1]\n    tx2 = boxes[i, 2]\n    ty2 = boxes[i, 3]\n    ts = boxes[i, 4]\n\n    pos = i + 1\n    # NMS iterations, note that N changes if detection boxes fall below thresholdï¼ŒNå€¼æ˜¯åŠ¨æ€å˜åŒ–çš„\n    while pos &lt; N:  # å‘ååšNMSæ¯”è¾ƒ\n        x1 = boxes[pos, 0]  # å½“å‰ä½ç½®çš„bbox\n        y1 = boxes[pos, 1]\n        x2 = boxes[pos, 2]\n        y2 = boxes[pos, 3]\n        s = boxes[pos, 4]\n\n        area = (x2 - x1 + 1) * (y2 - y1 + 1)  # posä¸‹boxçš„é¢ç§¯\n        iw = (min(tx2, x2) - max(tx1, x1) + 1)  # è®¡ç®—Insectionçš„å®½iwï¼Œå¦‚æœiw &lt; 0ï¼Œè¯´æ˜æ²¡ç›¸äº¤ï¼Œå¯ä»¥ç›´æ¥å¿½ç•¥äº†\n        if iw &gt; 0:\n            ih = (min(ty2, y2) - max(ty1, y1) + 1)  # è®¡ç®—Insectionçš„å®½ihï¼Œå¦‚æœih &lt; 0ï¼Œè¯´æ˜æ²¡ç›¸äº¤ï¼Œå¯ä»¥ç›´æ¥å¿½ç•¥äº†\n            if ih &gt; 0:\n                ua = float((tx2 - tx1 + 1) * (ty2 - ty1 + 1) + area - iw * ih)  # Uçš„é¢ç§¯\n                ov = iw * ih / ua  # iou between max box and detection box\n\n                if method == 1:  # soft_nmsä¸­linearé™æƒæ“ä½œï¼Œä¸ovè´Ÿç›¸å…³\n                    if ov &gt; Nt:\n                        weight = 1 - ov\n                    else:\n                        weight = 1\n                elif method == 2:  # soft_nmsä¸­gaussiané™æƒæ“ä½œ\n                    weight = np.exp(-(ov * ov) / sigma)\n                else:  # original NMSï¼Œweight = 0å°±ç›´æ¥æŠŠscoreç½®0\n                    if ov &gt; Nt:\n                        weight = 0\n                    else:\n                        weight = 1\n\n                boxes[pos, 4] = weight * boxes[pos, 4]  # æƒé‡é‡æ–°è°ƒæ•´\n\n                # if box score falls below threshold, discard the box by swapping with last boxï¼Œupdate N\n                # å¦‚æœbboxè°ƒæ•´åçš„æƒé‡ï¼Œå·²ç»å°äºé˜ˆå€¼thresholdï¼Œé‚£ä¹ˆè¿™ä¸ªbboxå°±å¯ä»¥å¿½ç•¥äº†ï¼Œ\n                # æ“ä½œæ–¹å¼æ˜¯ç›´æ¥ç”¨æœ€åä¸€ä¸ªæœ‰æ•ˆçš„bboxæ›¿æ¢å½“å‰posä¸Šçš„bbox\n                if boxes[pos, 4] &lt; threshold:\n                    boxes[pos, 0] = boxes[N - 1, 0]\n                    boxes[pos, 1] = boxes[N - 1, 1]\n                    boxes[pos, 2] = boxes[N - 1, 2]\n                    boxes[pos, 3] = boxes[N - 1, 3]\n                    boxes[pos, 4] = boxes[N - 1, 4]\n                    N = N - 1  # N-1ä½ç½®ä¸Šçš„bboxå·²ç»èµ‹å€¼åˆ°å‰é¢äº†ï¼Œè¯¥bboxå°±å¯ä»¥å¿½ç•¥äº†ï¼›\n                    pos = pos - 1  # posä½ç½®ä¸Šå¼•å…¥äº†æ–°çš„æœ‰æ•ˆbbox(N-1)ï¼Œå°±éœ€è¦å†è®¡ç®—ä¸€éäº†\n\n        pos = pos + 1  # å½“å‰pos bboxè®¡ç®—å®Œæ¯•\n\n# æ±‚æ»¡è¶³soft_nmsç­›é€‰æ¡ä»¶çš„æ‰€æœ‰bboxæ•°é‡ï¼Œå¹¶æ‰“æ•£ä¸ºlistï¼Œä½†ä¸€ä¸ªé—®é¢˜æ˜¯ï¼šå¦‚ä½•ä¸bbox indexå¯¹åº”èµ·æ¥ï¼Ÿ\n# æ–¹å¼å¾ˆç®€å•ï¼Œbboxä¹Ÿåšäº†å¯¹åº”çš„è°ƒæ•´ã€ç­›é€‰ï¼Œbbox listä¸­top-Nå°±å¯¹åº”ç€æœ€é«˜scoreï¼Œä¸”soft-nmsç­›é€‰é€šè¿‡çš„bboxï¼Œ\n# ä¸è¿‡æ¯ä¸ªbboxçš„scoreä¹ŸåŒæ ·ç»è¿‡soft-nmsè°ƒæ•´äº†\nkeep = [i for i in range(N)]\n\nreturn keep</code></pre>\n<h6 id=\"ç‰ˆæœ¬2\">ç‰ˆæœ¬2</h6>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">def py_cpu_softnms(dets, sc, Nt&#x3D;0.3, sigma&#x3D;0.5, thresh&#x3D;0.001, method&#x3D;2):\n    &quot;&quot;&quot;\n    py_cpu_softnms\n    :param dets:   boexs åæ ‡çŸ©é˜µ format [y1, x1, y2, x2]\n    :param sc:     æ¯ä¸ª boxes å¯¹åº”çš„åˆ†æ•°\n    :param Nt:     iou äº¤å é—¨é™\n    :param sigma:  ä½¿ç”¨ gaussian å‡½æ•°çš„æ–¹å·®\n    :param thresh: æœ€åçš„åˆ†æ•°é—¨é™\n    :param method: ä½¿ç”¨çš„æ–¹æ³•\n    :return:       ç•™ä¸‹çš„ boxes çš„ index\n    &quot;&quot;&quot;\n\n    # indexes concatenate boxes with the last column\n    N &#x3D; dets.shape[0]\n    indexes &#x3D; np.array([np.arange(N)])\n    dets &#x3D; np.concatenate((dets, indexes.T), axis&#x3D;1)\n\n    # the order of boxes coordinate is [y1,x1,y2,x2]\n    y1 &#x3D; dets[:, 0]\n    x1 &#x3D; dets[:, 1]\n    y2 &#x3D; dets[:, 2]\n    x2 &#x3D; dets[:, 3]\n    scores &#x3D; sc\n    areas &#x3D; (x2 - x1 + 1) * (y2 - y1 + 1)\n\n    for i in range(N):\n        # intermediate parameters for later parameters exchange\n        tBD &#x3D; dets[i, :].copy()\n        tscore &#x3D; scores[i].copy()\n        tarea &#x3D; areas[i].copy()\n        pos &#x3D; i + 1\n\n        #\n        if i !&#x3D; N-1:\n            maxscore &#x3D; np.max(scores[pos:], axis&#x3D;0)\n            maxpos &#x3D; np.argmax(scores[pos:], axis&#x3D;0)\n        else:\n            maxscore &#x3D; scores[-1]\n            maxpos &#x3D; 0\n        if tscore &lt; maxscore:\n            dets[i, :] &#x3D; dets[maxpos + i + 1, :]\n            dets[maxpos + i + 1, :] &#x3D; tBD\n            tBD &#x3D; dets[i, :]\n\n            scores[i] &#x3D; scores[maxpos + i + 1]\n            scores[maxpos + i + 1] &#x3D; tscore\n            tscore &#x3D; scores[i]\n\n            areas[i] &#x3D; areas[maxpos + i + 1]\n            areas[maxpos + i + 1] &#x3D; tarea\n            tarea &#x3D; areas[i]\n\n        # IoU calculate\n        xx1 &#x3D; np.maximum(dets[i, 1], dets[pos:, 1])\n        yy1 &#x3D; np.maximum(dets[i, 0], dets[pos:, 0])\n        xx2 &#x3D; np.minimum(dets[i, 3], dets[pos:, 3])\n        yy2 &#x3D; np.minimum(dets[i, 2], dets[pos:, 2])\n\n        w &#x3D; np.maximum(0.0, xx2 - xx1 + 1)\n        h &#x3D; np.maximum(0.0, yy2 - yy1 + 1)\n        inter &#x3D; w * h\n        ovr &#x3D; inter &#x2F; (areas[i] + areas[pos:] - inter)\n\n        # Three methods: 1.linear 2.gaussian 3.original NMS\n        if method &#x3D;&#x3D; 1:  # linear\n            weight &#x3D; np.ones(ovr.shape)\n            weight[ovr &gt; Nt] &#x3D; weight[ovr &gt; Nt] - ovr[ovr &gt; Nt]\n        elif method &#x3D;&#x3D; 2:  # gaussian\n            weight &#x3D; np.exp(-(ovr * ovr) &#x2F; sigma)\n        else:  # original NMS\n            weight &#x3D; np.ones(ovr.shape)\n            weight[ovr &gt; Nt] &#x3D; 0\n\n        scores[pos:] &#x3D; weight * scores[pos:]\n\n    # select the boxes and keep the corresponding indexes\n    inds &#x3D; dets[:, 4][scores &gt; thresh]\n    keep &#x3D; inds.astype(int)\n\n    return keep<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">def test():\n    # boxes and scores\n    boxes &#x3D; np.array([[200, 200, 400, 400], [220, 220, 420, 420], [200, 240, 400, 440], [240, 200, 440, 400], [1, 1, 2, 2]], dtype&#x3D;np.float32)\n    boxscores &#x3D; np.array([0.9, 0.8, 0.7, 0.6, 0.5], dtype&#x3D;np.float32)\n    index &#x3D; py_cpu_softnms(boxes, boxscores, method&#x3D;3)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"c-4\">c++</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n#include &lt;bits&#x2F;stdc++.h&gt;\n\nnamespace nms\n&#123;\nstruct proposal\n&#123;\n  float score, x1, y1, x2, y2;\n&#125;;\n\ninline static bool cmp(const proposal&amp; a, const proposal&amp; b)\n&#123;\n  return a.score &lt; b.score;\n&#125;\n\ninline static float iou(const proposal&amp;, const proposal&amp;) __attribute__((always_inline));\n\nstatic float iou(const proposal&amp; a, const proposal&amp; b)\n&#123;\n  auto overlap &#x3D; 0.f;\n  float iw  &#x3D; std::min(b.x2, a.x2) - std::max(b.x1, a.x1) + 1;\n  if (iw &gt; 0) &#123;\n    float ih &#x3D; std::min(b.y2, a.y2) - std::max(b.y1, a.y1) + 1;\n    if (ih &gt; 0) &#123;\n      float ab &#x3D; (b.x2 - b.x1 + 1) * (b.y2 - b.y1 + 1);\n      float aa &#x3D; (a.x2 - a.x1 + 1) * (a.y2 - a.y1 + 1);\n      float inter &#x3D; iw * ih;\n      overlap &#x3D; inter &#x2F; (aa + ab - inter);\n    &#125;\n  &#125;\n  return overlap;\n&#125;\n\nenum class Method : uint32_t\n&#123;\n  LINEAR &#x3D; 0,\n  GAUSSIAN,\n  HARD\n&#125;;\n\nsize_t soft_nms(float* boxes,\n                int32_t* index,\n                size_t count,\n                Method method,\n                float Nt,\n                float sigma,\n                float threshold)\n&#123;\n  std::iota(index, index + count, 0);  &#x2F;&#x2F; np.arange()\n  auto p &#x3D; reinterpret_cast&lt;proposal*&gt;(boxes);\n\n  auto N &#x3D; count;\n  for (size_t i &#x3D; 0; i &lt; N; ++i) &#123;\n    auto max &#x3D; std::max_element(p + i, p + N, cmp);\n    std::swap(p[i], *max);\n    std::swap(index[i], index[max - p]);\n\n    auto j      &#x3D; i + 1;\n    auto weight &#x3D; 0.f;\n    while (j &lt; N) &#123;\n      auto ov &#x3D; iou(p[i], p[j]);\n      switch (method) &#123;\n        case Method::LINEAR:\n          weight &#x3D; ov &gt; Nt ? 1.f - ov : 1.f;\n          break;\n        case Method::GAUSSIAN:\n          weight &#x3D; std::exp(-(ov * ov) &#x2F; sigma);\n          break;\n        case Method::HARD:\n          weight &#x3D; ov &gt; Nt ? 0.f : 1.f;\n          break;\n      &#125;\n      p[j].score *&#x3D; weight;\n      if (p[j].score &lt; threshold) &#123;\n        N--;\n        std::swap(p[j], p[N]);\n        std::swap(index[j], index[N]);\n        j--;\n      &#125;\n      j++;\n    &#125;\n  &#125;;\n\n  return N;\n&#125;\n&#125; &#x2F;* namespace nms *&#x2F;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"å®ç°one-hotç‰¹å¾\">7. å®ç°one-hotç‰¹å¾</h4>\n<h5 id=\"python-5\">python</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">one_hot_t&#x3D; np.zeros_like(y)  #ç”Ÿæˆå’Œyå½¢çŠ¶ä¸€æ ·çš„å…ƒç´ ä¸ºé›¶çš„æ•°ç»„\nfor j, i in zip(range(t.size), t):\n    #æœ‰å¤šå°‘ä¸ªæ ·æœ¬å°±åº”è¯¥å¯¹åº”å¤šå°‘ä¸ªæ ‡ç­¾\n    one_hot_t[j][i] &#x3D; 1      #å˜ä¸ºone-hotç±»å‹æ ‡ç­¾ï¼šjè¡¨ç¤ºæ ·æœ¬ï¼Œiè¡¨ç¤ºæ ‡ç­¾ç´¢å¼•\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"softmax\">8. softmax</h4>\n<h5 id=\"python-6\">python</h5>\n<p>ç”±äºæŒ‡æ•°å‡½æ•°çš„æ”¾å¤§ä½œç”¨è¿‡äºæ˜æ˜¾ï¼Œå¦‚æœç›´æ¥ä½¿ç”¨softmaxè®¡ç®—å…¬å¼ğ‘ ğ‘œğ‘“ğ‘¡ğ‘šğ‘ğ‘¥(ğ‘¥ğ‘–)=ğ‘’ğ‘¥ğ‘(ğ‘¥ğ‘–)/âˆ‘ğ‘’ğ‘¥ğ‘(ğ‘¥ğ‘—)è¿›è¡Œå‡½æ•°å®ç°ï¼Œå®¹æ˜“å¯¼è‡´æ•°æ®æº¢å‡º(ä¸Šæº¢)ã€‚æ‰€ä»¥æˆ‘ä»¬åœ¨å‡½æ•°å®ç°æ—¶åˆ©ç”¨å…¶æ€§è´¨ï¼šå…ˆå¯¹è¾“å…¥æ•°æ®è¿›è¡Œå¤„ç†ï¼Œä¹‹åå†åˆ©ç”¨è®¡ç®—å…¬å¼è®¡ç®—ã€‚å…·ä½“ä½¿å¾—å®ç°æ­¥éª¤ä¸ºï¼š æŸ¥æ‰¾æ¯ä¸ªå‘é‡xçš„æœ€å¤§å€¼cï¼› æ¯ä¸ªå‘é‡å‡å»å…¶æœ€å¤§å€¼c, å¾—åˆ°å‘é‡y = x-c; åˆ©ç”¨å…¬å¼è¿›è¡Œè®¡ç®—,softmax(x) = softmax(x-c) = softmax(y)</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import numpy as np\n\ndef softmax(x: np.array):\n    x_max &#x3D; np.max(x, axis&#x3D;-1, keepdims&#x3D;True)\n    x -&#x3D; x_max\n    x_exp &#x3D; np.exp(x)\n    s &#x3D; x_exp &#x2F; np.sum(x_exp, axis&#x3D;-1, keepdims&#x3D;True)\n    return s\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"å„ç§æ»¤æ³¢\">9. å„ç§æ»¤æ³¢</h4>\n<h5 id=\"é©¬èµ›å…‹\">é©¬èµ›å…‹</h5>\n<p>é©¬èµ›å…‹çš„å®ç°åŸç†æ˜¯æŠŠå›¾åƒä¸ŠæŸä¸ªåƒç´ ç‚¹ä¸€å®šèŒƒå›´é‚»åŸŸå†…çš„æ‰€æœ‰ç‚¹ç”¨é‚»åŸŸå†…å·¦ä¸Šåƒç´ ç‚¹çš„é¢œè‰²ä»£æ›¿ï¼Œè¿™æ ·å¯ä»¥æ¨¡ç³Šç»†èŠ‚ï¼Œä½†æ˜¯å¯ä»¥ä¿ç•™å¤§ä½“çš„è½®å»“ã€‚ <pre class=\"line-numbers language-none\"><code class=\"language-none\">import cv2\n\ndef do_mosaic(frame, x, y, w, h, neighbor&#x3D;9):\n    &quot;&quot;&quot;\n    :param frame: opencv frame\n    :param int x :  é©¬èµ›å…‹å·¦é¡¶ç‚¹\n    :param int y:  é©¬èµ›å…‹å³é¡¶ç‚¹\n    :param int w:  é©¬èµ›å…‹å®½\n    :param int h:  é©¬èµ›å…‹é«˜\n    :param int neighbor:  é©¬èµ›å…‹æ¯ä¸€å—çš„å®½\n    &quot;&quot;&quot;\n    fh, fw &#x3D; frame.shape[0], frame.shape[1]\n    if (y + h &gt; fh) or (x + w &gt; fw):\n        return\n    for i in range(0, h - neighbor, neighbor):  # å…³é”®ç‚¹0 å‡å»neightbour é˜²æ­¢æº¢å‡º\n        for j in range(0, w - neighbor, neighbor):\n            rect &#x3D; [j + x, i + y, neighbor, neighbor]\n            color &#x3D; frame[i + y][j + x].tolist()  # å…³é”®ç‚¹1 tolist\n            left_up &#x3D; (rect[0], rect[1])\n            right_down &#x3D; (rect[0] + neighbor - 1, rect[1] + neighbor - 1)  # å…³é”®ç‚¹2 å‡å»ä¸€ä¸ªåƒç´ \n            cv2.rectangle(frame, left_up, right_down, color, -1)\n\n\nim &#x3D; cv2.imread(&#39;test.jpg&#39;, 1)\ndo_mosaic(im, 219, 61, 460 - 219, 412 - 61)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>\n<h5 id=\"é«˜æ–¯æ»¤æ³¢\">é«˜æ–¯æ»¤æ³¢</h5>\n<p><a href=\"https://www.cnblogs.com/wojianxin/p/12498391.html\">å‡ºå¤„</a></p>\n<figure>\n<img src=\"https://img-blog.csdn.net/20171203094927312\" alt=\"äºŒç»´é«˜æ–¯å‡½æ•°\" /><figcaption aria-hidden=\"true\">äºŒç»´é«˜æ–¯å‡½æ•°</figcaption>\n</figure>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import cv2\nimport numpy as np\n\ndef gaussian_filter(img, K_size&#x3D;3, sigma&#x3D;1.3):\n\n    if len(img.shape) &#x3D;&#x3D; 3:\n        H, W, C &#x3D; img.shape\n    else:\n        img &#x3D; np.expand_dims(img, axis&#x3D;-1)\n        H, W, C &#x3D; img.shape\n\n    ## Zero padding\n    pad &#x3D; K_size &#x2F;&#x2F; 2\n    out &#x3D; np.zeros((H + pad * 2, W + pad * 2, C), dtype&#x3D;np.float)\n    out[pad: pad + H, pad: pad + W] &#x3D; img.copy().astype(np.float)\n\n    ## prepare Kernel\n    K &#x3D; np.zeros((K_size, K_size), dtype&#x3D;np.float)\n    for x in range(-pad, -pad + K_size):\n        for y in range(-pad, -pad + K_size):\n            K[y + pad, x + pad] &#x3D; np.exp( -(x ** 2 + y ** 2) &#x2F; (2 * (sigma ** 2)))\n\n    K &#x2F;&#x3D; (2 * np.pi * sigma * sigma)\n    K &#x2F;&#x3D; K.sum()\n    tmp &#x3D; out.copy()\n\n    # filtering\n    for y in range(H):\n        for x in range(W):\n            for c in range(C):\n                out[pad + y, pad + x, c] &#x3D; np.sum(K * tmp[y: y + K_size, x: x + K_size, c])\n\n    out &#x3D; np.clip(out, 0, 255)\n    out &#x3D; out[pad: pad + H, pad: pad + W].astype(np.uint8)\n    return out\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"å‡å€¼æ»¤æ³¢\">å‡å€¼æ»¤æ³¢</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import numpy as np\n\n\ndef means_filter(input_image, filter_size):\n    &#39;&#39;&#39;\n    å‡å€¼æ»¤æ³¢å™¨\n    :param input_image: è¾“å…¥å›¾åƒ\n    :param filter_size: æ»¤æ³¢å™¨å¤§å°\n    :return: è¾“å‡ºå›¾åƒ\n\n    æ³¨ï¼šæ­¤å®ç°æ»¤æ³¢å™¨å¤§å°å¿…é¡»ä¸ºå¥‡æ•°ä¸” &gt;&#x3D; 3\n    &#39;&#39;&#39;\n    input_image_cp &#x3D; np.copy(input_image)  # è¾“å…¥å›¾åƒçš„å‰¯æœ¬\n    filter_template &#x3D; np.ones((filter_size, filter_size))  # ç©ºé—´æ»¤æ³¢å™¨æ¨¡æ¿\n    pad_num &#x3D; int((filter_size - 1) &#x2F; 2)  # è¾“å…¥å›¾åƒéœ€è¦å¡«å……çš„å°ºå¯¸\n    input_image_cp &#x3D; np.pad(input_image_cp, (pad_num, pad_num), mode&#x3D;&quot;constant&quot;, constant_values&#x3D;0)  # å¡«å……è¾“å…¥å›¾åƒ\n    m, n &#x3D; input_image_cp.shape  # è·å–å¡«å……åçš„è¾“å…¥å›¾åƒçš„å¤§å°\n    output_image &#x3D; np.copy(input_image_cp)  # è¾“å‡ºå›¾åƒ\n\n    # ç©ºé—´æ»¤æ³¢\n    for i in range(pad_num, m - pad_num):\n        for j in range(pad_num, n - pad_num):\n            output_image[i, j] &#x3D; np.sum(filter_template * input_image_cp[i - pad_num:i + pad_num + 1, j - pad_num:j + pad_num + 1]) &#x2F; (filter_size ** 2)\n    output_image &#x3D; output_image[pad_num:m - pad_num, pad_num:n - pad_num]  # è£å‰ª\n\n    return output_image<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"ä¸­å€¼æ»¤æ³¢\">ä¸­å€¼æ»¤æ³¢</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"># ä¸­å€¼æ»¤æ³¢#\nimport cv2\nimport numpy as np\n\ndef MedianFilter(img,k&#x3D;3,padding&#x3D;None):\n    imarray&#x3D;img\n    height &#x3D; imarray.shape[0]\n    width &#x3D; imarray.shape[1]\n    if not padding:\n        edge &#x3D; int((k - 1) &#x2F; 2)\n        if height - 1 - edge &lt;&#x3D; edge or width - 1 - edge &lt;&#x3D; edge:\n            print(&quot;The parameter k is to large.&quot;)\n            return None\n        new_arr &#x3D; np.zeros((height, width), dtype&#x3D;&quot;uint8&quot;)\n        for i in range(edge,height-edge):\n            for j in range(edge,width-edge):\n                new_arr[i, j] &#x3D; np.median(imarray[i - edge:i + edge + 1, j - edge:j + edge + 1])# è°ƒç”¨np.medianæ±‚å–ä¸­å€¼\n    return new_arr\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"kmeans\">Kmeans</h4>\n<p>https://zhuanlan.zhihu.com/p/35959301 #### ç§¯åˆ†å›¾å‡å€¼æ»¤æ³¢ https://blog.csdn.net/weixin_40647819/article/details/88775598</p>\n","feature":true,"text":"1. IOU python def bb_intersection_over_union(boxA, boxB): boxA &#x3D; [int(x) for x in boxA] boxB &#x3D; [int(x) for x in boxB] xA &#x3D; ma...","link":"","photos":[],"count_time":{"symbolsCount":"28k","symbolsTime":"25 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#iou\"><span class=\"toc-text\">1. IOU</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#python\"><span class=\"toc-text\">python</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#c\"><span class=\"toc-text\">c++</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#nms\"><span class=\"toc-text\">2. NMS</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#python-1\"><span class=\"toc-text\">python</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#c-1\"><span class=\"toc-text\">c++</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8D%B7%E7%A7%AF\"><span class=\"toc-text\">3. å·ç§¯</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#python-2\"><span class=\"toc-text\">python</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#c-2\"><span class=\"toc-text\">c++</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#pooling\"><span class=\"toc-text\">4. Pooling</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#maxpooling\"><span class=\"toc-text\">maxpooling</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E7%89%88%E6%9C%AC1%E7%AE%80%E5%8D%95%E7%89%88\"><span class=\"toc-text\">ç‰ˆæœ¬1(ç®€å•ç‰ˆ)</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E7%89%88%E6%9C%AC2%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD\"><span class=\"toc-text\">ç‰ˆæœ¬2(åå‘ä¼ æ’­)</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#avg-pooling\"><span class=\"toc-text\">avg-pooling</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E7%89%88%E6%9C%AC1%E7%AE%80%E5%8D%95%E7%89%88-1\"><span class=\"toc-text\">ç‰ˆæœ¬1(ç®€å•ç‰ˆ)</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E7%89%88%E6%9C%AC2%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD-1\"><span class=\"toc-text\">ç‰ˆæœ¬2(åå‘ä¼ æ’­)</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#map\"><span class=\"toc-text\">5. mAP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#python-3\"><span class=\"toc-text\">python</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#c-3\"><span class=\"toc-text\">c++</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#softnms\"><span class=\"toc-text\">6. softnms</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#python-4\"><span class=\"toc-text\">python</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E7%89%88%E6%9C%AC1\"><span class=\"toc-text\">ç‰ˆæœ¬1</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#soft_nms%E6%93%8D%E4%BD%9C%E8%BF%99%E9%87%8C%E5%81%87%E8%AE%BEboxes%E6%98%AF%E6%97%A0%E5%BA%8F%E6%9C%AA%E6%8C%89score%E5%81%9A%E9%99%8D%E5%BA%8F%E7%9A%84%E6%89%80%E4%BB%A5%E6%AF%8F%E8%BD%AEsoft_nms%E8%BF%AD%E4%BB%A3%E9%83%BD%E9%9C%80%E8%A6%81%E7%B1%BB%E4%BC%BC%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C%E9%80%89%E6%8B%A9%E5%BD%93%E5%89%8Dtop-1-bbox%E5%81%9Anms\"><span class=\"toc-text\">soft_nmsæ“ä½œï¼Œè¿™é‡Œå‡è®¾boxesæ˜¯æ— åº(æœªæŒ‰scoreåšé™åº)çš„ï¼Œæ‰€ä»¥æ¯è½®soft_nmsè¿­ä»£éƒ½éœ€è¦ç±»ä¼¼å†’æ³¡æ’åºæ“ä½œï¼Œé€‰æ‹©å½“å‰top-1 bboxåšNMS</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#nt%E8%AE%A1%E7%AE%97iou%E7%9A%84%E9%98%88%E5%80%BCiou-nt%E5%AF%B9%E5%BA%94bbox%E7%9A%84score%E6%9D%83%E9%87%8D%E5%B0%B1%E8%A6%81%E9%99%8D%E4%BD%8E\"><span class=\"toc-text\">Ntï¼šè®¡ç®—IoUçš„é˜ˆå€¼ï¼ŒIoU &gt; Ntï¼Œå¯¹åº”bboxçš„scoreæƒé‡å°±è¦é™ä½</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#threshold%E9%99%8D%E6%9D%83%E5%90%8E%E9%80%9A%E8%BF%87threshold%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%89%94%E9%99%A4%E4%BD%8E%E6%9D%83%E9%87%8Dbbox\"><span class=\"toc-text\">thresholdï¼šé™æƒåé€šè¿‡thresholdè¿›ä¸€æ­¥å‰”é™¤ä½æƒé‡bbox</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E7%89%88%E6%9C%AC2\"><span class=\"toc-text\">ç‰ˆæœ¬2</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#c-4\"><span class=\"toc-text\">c++</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0one-hot%E7%89%B9%E5%BE%81\"><span class=\"toc-text\">7. å®ç°one-hotç‰¹å¾</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#python-5\"><span class=\"toc-text\">python</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#softmax\"><span class=\"toc-text\">8. softmax</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#python-6\"><span class=\"toc-text\">python</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%90%84%E7%A7%8D%E6%BB%A4%E6%B3%A2\"><span class=\"toc-text\">9. å„ç§æ»¤æ³¢</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%A9%AC%E8%B5%9B%E5%85%8B\"><span class=\"toc-text\">é©¬èµ›å…‹</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%AB%98%E6%96%AF%E6%BB%A4%E6%B3%A2\"><span class=\"toc-text\">é«˜æ–¯æ»¤æ³¢</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2\"><span class=\"toc-text\">å‡å€¼æ»¤æ³¢</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2\"><span class=\"toc-text\">ä¸­å€¼æ»¤æ³¢</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#kmeans\"><span class=\"toc-text\">Kmeans</span></a></li></ol>","author":{"name":"Hulk Wang","slug":"blog-author","avatar":"/images/avatar_small.jpg","link":"https://github.com/TalkUHulk","description":"I'm æµ©å…‹ï¼ŒCVç®—æ³•å·¥ç¨‹å¸ˆï¼Œçƒ­è¡·äºå„ç§æœ‰è¶£çš„æŠ€æœ¯ï¼Œæ­¤åšå®¢ä¸»è¦ç”¨æ¥åšå­¦ä¹ æ€»ç»“ï¼Œæ€æ­»æ‹–å»¶ç—‡ã€‚<br /> <img src=\"/images/funny.gif\" height=\"240\" width=\"360\"/>","socials":{"github":"https://github.com/TalkUHulk","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/311127773","zhihu":"https://www.zhihu.com/people/MisterAntebellum","csdn":"https://blog.csdn.net/hyqwmxsh","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"CVé¢è¯•åŸºç¡€æ€»ç»“","uid":"2d84f3892209cec11720cffbf464a897","slug":"CVé¢è¯•åŸºç¡€æ€»ç»“","date":"2021-10-12T07:57:22.000Z","updated":"2021-10-27T02:54:44.304Z","comments":true,"path":"api/articles/CVé¢è¯•åŸºç¡€æ€»ç»“.json","keywords":null,"cover":[],"text":"1. è¯„æµ‹æŒ‡æ ‡ 1.1 åŸºæœ¬æ¦‚å¿µ TP TN FP FN T-Ture;F-False è¡¨ç¤ºé¢„æµ‹ç»“æœçš„æ­£ç¡®æ€§ï¼ŒTè¡¨ç¤ºé¢„æµ‹æ­£ç¡®ï¼ŒFè¡¨ç¤ºé¢„æµ‹é”™è¯¯ï¼› P-positive;N-negative è¡¨ç¤ºé¢„æµ‹çš„æ­£è´Ÿæ€§ï¼ŒPè¡¨ç¤ºé¢„æµ‹ä¸ºæ­£æ ·æœ¬ï¼ŒNè¡¨ç¤ºé¢„æµ‹ä¸ºè´Ÿæ ·æœ¬ï¼› --- --- TPâ€”â€”True...","link":"","photos":[],"count_time":{"symbolsCount":"44k","symbolsTime":"40 mins."},"categories":[],"tags":[{"name":"é¢è¯•åŸºç¡€","slug":"é¢è¯•åŸºç¡€","count":1,"path":"api/tags/é¢è¯•åŸºç¡€.json"}],"author":{"name":"Hulk Wang","slug":"blog-author","avatar":"/images/avatar_small.jpg","link":"https://github.com/TalkUHulk","description":"I'm æµ©å…‹ï¼ŒCVç®—æ³•å·¥ç¨‹å¸ˆï¼Œçƒ­è¡·äºå„ç§æœ‰è¶£çš„æŠ€æœ¯ï¼Œæ­¤åšå®¢ä¸»è¦ç”¨æ¥åšå­¦ä¹ æ€»ç»“ï¼Œæ€æ­»æ‹–å»¶ç—‡ã€‚<br /> <img src=\"/images/funny.gif\" height=\"240\" width=\"360\"/>","socials":{"github":"https://github.com/TalkUHulk","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/311127773","zhihu":"https://www.zhihu.com/people/MisterAntebellum","csdn":"https://blog.csdn.net/hyqwmxsh","juejin":"","customs":{}}},"feature":true}}