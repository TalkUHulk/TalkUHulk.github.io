{"title":"手撕代码","uid":"66e6fbbf30cdfd5fb293d5ee17ed3935","slug":"手撕代码","date":"2021-10-19T03:41:08.000Z","updated":"2021-10-27T03:08:21.107Z","comments":true,"path":"api/articles/手撕代码.json","keywords":null,"cover":null,"content":"<h4 id=\"iou\">1. IOU</h4>\n<h5 id=\"python\">python</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">def bb_intersection_over_union(boxA, boxB):\n    boxA &#x3D; [int(x) for x in boxA]\n    boxB &#x3D; [int(x) for x in boxB]\n\n    xA &#x3D; max(boxA[0], boxB[0])\n    yA &#x3D; max(boxA[1], boxB[1])\n    xB &#x3D; min(boxA[2], boxB[2])\n    yB &#x3D; min(boxA[3], boxB[3])\n\n    interArea &#x3D; max(0, xB - xA + 1) * max(0, yB - yA + 1)\n\n    boxAArea &#x3D; (boxA[2] - boxA[0] + 1) * (boxA[3] - boxA[1] + 1)\n    boxBArea &#x3D; (boxB[2] - boxB[0] + 1) * (boxB[3] - boxB[1] + 1)\n    \n    iou &#x3D; interArea &#x2F; float(boxAArea + boxBArea - interArea)\n\n    return iou<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"c\">c++</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\ntypedef struct Bbox\n&#123;\n    int x1;\n    int y1;\n    int x2;\n    int y2;\n    float score;\n&#125;Bbox;\n\nfloat iou(Bbox box1,Bbox box2)\n&#123;\n    max_x &#x3D; max(box1.x1,box2.x1);  &#x2F;&#x2F; 找出左上角坐标哪个大\n    min_x &#x3D; min(box1.x2,box2.x2);  &#x2F;&#x2F; 找出右上角坐标哪个小\n    max_y &#x3D; max(box1.y1,box2.y1);\n    min_y &#x3D; min(box1.y2,box2.y2);\n    if(min_x&lt;&#x3D;max_x || min_y&lt;&#x3D;max_y) &#x2F;&#x2F; 如果没有重叠\n        return 0;\n    float over_area &#x3D; (min_x - max_x) * (min_y - max_y);  &#x2F;&#x2F; 计算重叠面积\n    float area_a &#x3D; (box1.x2 - boxa.x1) * (box1.y2 - boxa.y1);\n    float area_b &#x3D; (box2.x2 - boxb.x1) * (box2.y2 - boxb.y1);\n    float iou &#x3D; over_area &#x2F; (area_a + area_b - over_area);\n    return iou;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"nms\">2. NMS</h4>\n<h5 id=\"python-1\">python</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">def nms(det, thresh):\n    x1 &#x3D; det[..., 0]\n    y1 &#x3D; det[..., 1]\n    x2 &#x3D; det[..., 2]\n    y2 &#x3D; det[..., 3]\n    scores &#x3D; det[..., 4]\n    area &#x3D; (x2 - x1 + 1) * (y2 - y1 + 1)\n    order &#x3D; np.argsort(scores)[::-1]  # Returns the indices that would sort an array.\n    keep &#x3D; []\n    while order.size &gt; 0:\n        i &#x3D; order[0]\n        keep.append(i)\n        xx1 &#x3D; np.maximum(x1[i], x1[order[1:]])\n        yy1 &#x3D; np.maximum(y1[i], y1[order[1:]])\n        xx2 &#x3D; np.minimum(x2[i], x2[order[1:]])\n        yy2 &#x3D; np.minimum(x2[i], x2[order[1:]])\n        w &#x3D; np.maximum(0, xx2 - xx1 + 1)\n        h &#x3D; np.maximum(0, yy2 - yy1 + 1)\n        inter &#x3D; w * h\n        union &#x3D; area[i] + area[order[1:]] - inter\n        iou &#x3D; inter &#x2F; union\n        next_i &#x3D; np.where(iou &lt;&#x3D; thresh)[0]  # 只有条件 (condition)，没有x和y，则输出满足条件 (即非0) 元素的坐标\n        order &#x3D; order[next_i + 1]\n    return keep<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"c-1\">c++</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;*\n  将bbx按照confidence从高到低排序\n*&#x2F;\nbool sort_score(Bbox box1,Bbox box2)\n&#123;\n    return (box1.score &gt; box2.score);\n&#125;\n&#x2F;*\n(1) 获取当前目标类别下所有bbx的信息\n(2) 将bbx按照confidence从高到低排序,并记录当前confidence最大的bbx\n(3) 计算最大confidence对应的bbx与剩下所有的bbx的IOU,移除所有大于IOU阈值的bbx\n(4) 对剩下的bbx，循环执行(2)和(3)直到所有的bbx均满足要求（即不能再移除bbx）\n*&#x2F;\nvector&lt;Bbox&gt; nms(vector&lt;Bbox&gt;&amp;vec_boxs, float threshold)\n&#123;\n    vector&lt;Bbox&gt;  res;\n    while(vec_boxs.size() &gt; 0)\n    &#123;\n        sort(vec_boxs.begin(),vec_boxs.end(),cmp);\n        res.push_back(vec_boxs[0]);\n        for(int i &#x3D;0;i &lt;vec_boxs.size()-1;i++)\n        &#123;\n            float iou_value &#x3D;iou(vec_boxs[0],vec_boxs[i+1]);\n            if (iou_value &gt;threshold)\n            &#123;\n                vec_boxs.erase(vec_boxs[i+1]);\n            &#125;\n        &#125;\n        vec_boxs.erase(vec_boxs[0]);  &#x2F;&#x2F; res 已经保存，所以可以将最大的删除了\n \n    &#125;\n    return res;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"卷积\">3. 卷积</h4>\n<h5 id=\"python-2\">python</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">def conv_naive(x, c_out, ksize&#x3D;3, padding&#x3D;0, stride&#x3D;1):\n    b, c_in, h, w &#x3D; x.shape\n    kernel &#x3D; np.random.rand(c_out, c_in, ksize, ksize)\n    out_height &#x3D; (h - ksize + 2 * padding) &#x2F;&#x2F; stride + 1\n    out_width &#x3D; (w - ksize + 2 * padding) &#x2F;&#x2F; stride + 1\n\n    out_x &#x3D; np.random.rand(b, c_out, out_height,  out_width)\n    if padding &gt; 0:\n        pad_x &#x3D; np.zeros((b, c_in, h + 2 * padding, w + 2 * padding))\n        pad_x[..., padding:-padding, padding:-padding] &#x3D; x\n    else:\n        pad_x &#x3D; x\n\n    for y in range(out_height):\n        for x in range(out_width):\n            roi &#x3D; pad_x[..., y * stride:y * stride + ksize, x * stride: x * stride + ksize]\n            conv &#x3D; np.tile(np.expand_dims(roi, axis&#x3D;1), (1, c_out, 1, 1, 1)) * kernel\n            # conv &#x3D; np.repeat(np.expand_dims(roi, axis&#x3D;1), axis&#x3D;1, repeats&#x3D;c_out) * kernel\n            out_x[..., y, x] &#x3D; np.squeeze(np.sum(conv, axis&#x3D;(2, 3, 4), keepdims&#x3D;True), axis&#x3D;(2, 3, 4))\n\n    return out_x<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"c-2\">c++</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;二维卷积的实现\n#include&lt;cassert&gt;\n#include&lt;vector&gt;\n\n\nvoid conv2(int** filter, int **mat, int** res, const int filter_rows, const int filter_cols, const int mat_rows, const int mat_cols);&#x2F;&#x2F;指针数组版本\nstd::vector&lt;std::vector&lt;int&gt; &gt; conv2(std::vector&lt;std::vector&lt;int&gt; &gt; filter, std::vector&lt;std::vector&lt;int&gt; &gt; mat);&#x2F;&#x2F;向量版本\n\n\nint main(void)\n&#123;\n    return 0;\n&#125;&#x2F;&#x2F;main\n\nvoid conv2(int** filter, int **mat, int** res, const int filter_rows, const int filter_cols, const int mat_rows, const int mat_cols)\n&#123;\n    assert(filter_cols &lt; mat_cols &amp;&amp; filter_rows &lt; mat_rows);\n    for(int i &#x3D; 0; i &lt; mat_rows - 1; ++i)\n        for (int j &#x3D; 0; j &lt; mat_cols - 1; ++j)\n        &#123;\n            int tmp &#x3D; 0;\n            for (int m &#x3D; 0; m &lt; filter_rows; ++m)\n                for (int n &#x3D; 0; n &lt; filter_cols; ++n)\n                    if(0 &lt;&#x3D; i -m  &amp;&amp; i - m &lt; mat_rows &amp;&amp; 0 &lt;&#x3D; j - n &amp;&amp; j - n &lt; mat_cols)\n                        tmp +&#x3D; filter[m][n] * mat[i - m][j - n];&#x2F;&#x2F;卷积公式\n\n            res[i][j] &#x3D; tmp;\n        &#125;\n&#125;\n\nstd::vector&lt;std::vector&lt;int&gt; &gt; conv2(std::vector&lt;std::vector&lt;int&gt; &gt; filter, std::vector&lt;std::vector&lt;int&gt; &gt; mat )&#x2F;&#x2F;向量版本\n&#123;\n    const int filter_rows &#x3D; filter.size();\n    const int filter_cols &#x3D; filter[0].size();\n\n    const int mat_rows &#x3D; mat.size();\n    const int mat_cols &#x3D; mat[0].size();\n\n    assert(filter_cols &lt; mat_cols &amp;&amp; filter_rows &lt; mat_rows);\n    std::vector&lt;std::vector&lt;int&gt; &gt; res(mat_rows, std::vector&lt;int&gt;(mat_cols, 0));\n\n    for (int i &#x3D; 0; i &lt; mat_rows - 1; ++i)\n        for (int j &#x3D; 0; j &lt; mat_cols - 1; ++j)\n        &#123;\n            int tmp &#x3D; 0;\n            for (int m &#x3D; 0; m &lt; filter_rows; ++m)\n                for (int n &#x3D; 0; n &lt; filter_cols; ++n)\n                    if (0 &lt;&#x3D; i - m &amp;&amp; i - m &lt; mat_rows &amp;&amp; 0 &lt;&#x3D; j - n &amp;&amp; j - n &lt; mat_cols)\n                        tmp +&#x3D; filter[m][n] * mat[i - m][j - n];&#x2F;&#x2F;卷积公式\n\n            res[i][j] &#x3D; tmp;\n        &#125;\n    return res;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"pooling\">4. Pooling</h4>\n<h5 id=\"maxpooling\">maxpooling</h5>\n<h6 id=\"版本1简单版\">版本1(简单版)</h6>\n<p>def max_pooling(x, kernel_size=2, stride=2): b, c_in, h, w = x.shape ow = (w - kernel_size) // stride + 1 oh = (h - kernel_size) // stride + 1</p>\n<pre><code>out = np.zeros([b, c_in, oh, ow])\nx_input = x\nfor y in range(oh):\n    for x in range(ow):\n        roi = x_input[..., y * stride: y * stride + kernel_size, x * stride: x * stride + kernel_size]\n        max_val = np.squeeze(np.max(roi, axis=(2, 3), keepdims=True), axis=(2, 3))\n        out[..., y, x] = max_val\nreturn out</code></pre>\n<h6 id=\"版本2反向传播\">版本2(反向传播)</h6>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import numpy as np\nimport torch\nclass MaxPooling2D:\n    def __init__(self, kernel_size&#x3D;(2, 2), stride&#x3D;2):\n        self.kernel_size &#x3D; kernel_size\n        self.w_height &#x3D; kernel_size[0]\n        self.w_width &#x3D; kernel_size[1]\n\n        self.stride &#x3D; stride\n\n        self.x &#x3D; None\n        self.in_height &#x3D; None\n        self.in_width &#x3D; None\n\n        self.out_height &#x3D; None\n        self.out_width &#x3D; None\n\n        self.arg_max &#x3D; None\n\n    def __call__(self, x):\n        self.x &#x3D; x\n        self.in_height &#x3D; np.shape(x)[0]\n        self.in_width &#x3D; np.shape(x)[1]\n\n        self.out_height &#x3D; int((self.in_height - self.w_height) &#x2F; self.stride) + 1\n        self.out_width &#x3D; int((self.in_width - self.w_width) &#x2F; self.stride) + 1\n\n        out &#x3D; np.zeros((self.out_height, self.out_width))\n        self.arg_max &#x3D; np.zeros_like(out, dtype&#x3D;np.int32)\n\n        for i in range(self.out_height):\n            for j in range(self.out_width):\n                start_i &#x3D; i * self.stride\n                start_j &#x3D; j * self.stride\n                end_i &#x3D; start_i + self.w_height\n                end_j &#x3D; start_j + self.w_width\n                out[i, j] &#x3D; np.max(x[start_i: end_i, start_j: end_j])\n                self.arg_max[i, j] &#x3D; np.argmax(x[start_i: end_i, start_j: end_j])\n        self.arg_max &#x3D; self.arg_max\n        return out\n\n    def backward(self, d_loss):\n        dx &#x3D; np.zeros_like(self.x)\n        for i in range(self.out_height):\n            for j in range(self.out_width):\n                start_i &#x3D; i * self.stride\n                start_j &#x3D; j * self.stride\n                end_i &#x3D; start_i + self.w_height\n                end_j &#x3D; start_j + self.w_width\n                index &#x3D; np.unravel_index(self.arg_max[i, j], self.kernel_size)\n                dx[start_i:end_i, start_j:end_j][index] &#x3D; d_loss[i, j] #\n        return dx<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>test</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">np.set_printoptions(precision&#x3D;8, suppress&#x3D;True, linewidth&#x3D;120)\nx_numpy &#x3D; np.random.random((1, 1, 6, 9))\nx_tensor &#x3D; torch.tensor(x_numpy, requires_grad&#x3D;True)\n\nmax_pool_tensor &#x3D; torch.nn.MaxPool2d((2, 2), 2)\nmax_pool_numpy &#x3D; MaxPooling2D((2, 2), stride&#x3D;2)\n\nout_numpy &#x3D; max_pool_numpy(x_numpy[0, 0])\nout_tensor &#x3D; max_pool_tensor(x_tensor)\n\nd_loss_numpy &#x3D; np.random.random(out_tensor.shape)\nd_loss_tensor &#x3D; torch.tensor(d_loss_numpy, requires_grad&#x3D;True)\nout_tensor.backward(d_loss_tensor)\n\ndx_numpy &#x3D; max_pool_numpy.backward(d_loss_numpy[0, 0])\ndx_tensor &#x3D; x_tensor.grad\n# print(&#39;input \\n&#39;, x_numpy)\nprint(&quot;out_numpy \\n&quot;, out_numpy)\nprint(&quot;out_tensor \\n&quot;, out_tensor.data.numpy())\n\nprint(&quot;dx_numpy \\n&quot;, dx_numpy)\nprint(&quot;dx_tensor \\n&quot;, dx_tensor.data.numpy())<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">def pooling(feature_map, size&#x3D;2, stride&#x3D;2):\n    channel&#x3D;feature_map.shape[0]\n    height&#x3D;feature_map.shape[1]\n    width&#x3D;feature_map.shape[2]\n    padding_height&#x3D;np.uint16(round((height-size+1)&#x2F;stride))\n    padding_width&#x3D;np.uint16(round((width-size+1)&#x2F;stride))\n    print(padding_height,padding_width)\n\n    pool_out &#x3D; np.zeros((channel,padding_height,padding_width),dtype&#x3D;np.uint8)\n    \n    for map_num in range(channel):  \n        out_height &#x3D; 0  \n        for r in np.arange(0,height, stride):  \n            out_width &#x3D; 0  \n            for c in np.arange(0, width, stride):  \n                pool_out[map_num,out_height, out_width] &#x3D; np.max(feature_map[map_num,r:r+size,c:c+size])  \n                out_width&#x3D;out_width+1\n            out_height&#x3D;out_height+1\n    return pool_out<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"avg-pooling\">avg-pooling</h5>\n<h6 id=\"版本1简单版-1\">版本1(简单版)</h6>\n<p>def avg_pooling(x, kernel_size=2, stride=2): b, c_in, h, w = x.shape ow = (w - kernel_size) // stride + 1 oh = (h - kernel_size) // stride + 1</p>\n<pre><code>out = np.zeros([b, c_in, oh, ow])\nx_input = x\nfor y in range(oh):\n    for x in range(ow):\n        roi = x_input[..., y * stride: y * stride + kernel_size, x * stride: x * stride + kernel_size]\n        max_val = np.average(roi, axis=(2, 3))\n        out[..., y, x] = max_val\nreturn out</code></pre>\n<h6 id=\"版本2反向传播-1\">版本2(反向传播)</h6>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import numpy as np\nimport torch\n\nclass AvgPooling2D:\n    def __init__(self, kernel_size&#x3D;(2, 2), stride&#x3D;2):\n        self.stride &#x3D; stride\n        self.kernel_size &#x3D; kernel_size\n        self.w_height &#x3D; kernel_size[0]\n        self.w_width &#x3D; kernel_size[1]\n\n    def __call__(self, x):\n        self.x &#x3D; x\n        self.in_height &#x3D; x.shape[0]\n        self.in_width &#x3D; x.shape[1]\n\n        self.out_height &#x3D; int((self.in_height - self.w_height) &#x2F; self.stride) + 1\n        self.out_width &#x3D; int((self.in_width - self.w_width) &#x2F; self.stride) + 1\n        out &#x3D; np.zeros((self.out_height, self.out_width))\n\n        for i in range(self.out_height):\n            for j in range(self.out_width):\n                start_i &#x3D; i * self.stride\n                start_j &#x3D; j * self.stride\n                end_i &#x3D; start_i + self.w_height\n                end_j &#x3D; start_j + self.w_width\n                out[i, j] &#x3D; np.mean(x[start_i: end_i, start_j: end_j])\n        return out\n\n    def backward(self, d_loss):\n        dx &#x3D; np.zeros_like(self.x)\n\n        for i in range(self.out_height):\n            for j in range(self.out_width):\n                start_i &#x3D; i * self.stride\n                start_j &#x3D; j * self.stride\n                end_i &#x3D; start_i + self.w_height\n                end_j &#x3D; start_j + self.w_width\n                dx[start_i: end_i, start_j: end_j] &#x3D; d_loss[i, j] &#x2F; (self.w_width * self.w_height)\n        return dx\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>test</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">np.set_printoptions(precision&#x3D;8, suppress&#x3D;True, linewidth&#x3D;120)\nx_numpy &#x3D; np.random.random((1, 1, 6, 9))\nx_tensor &#x3D; torch.tensor(x_numpy, requires_grad&#x3D;True)\n\navg_pool_tensor &#x3D; torch.nn.AvgPool2d((2, 2), 2)\navg_pool_numpy &#x3D; AvgPooling2D((2, 2), stride&#x3D;2)\n\nout_numpy &#x3D; avg_pool_numpy(x_numpy[0, 0])\nout_tensor &#x3D; avg_pool_tensor(x_tensor)\n\nd_loss_numpy &#x3D; np.random.random(out_tensor.shape)\nd_loss_tensor &#x3D; torch.tensor(d_loss_numpy, requires_grad&#x3D;True)\nout_tensor.backward(d_loss_tensor)\n\ndx_numpy &#x3D; avg_pool_numpy.backward(d_loss_numpy[0, 0])\ndx_tensor &#x3D; x_tensor.grad\n# print(&#39;input \\n&#39;, x_numpy)\nprint(&quot;out_numpy \\n&quot;, out_numpy)\nprint(&quot;out_tensor \\n&quot;, out_tensor.data.numpy())\n\nprint(&quot;dx_numpy \\n&quot;, dx_numpy)\nprint(&quot;dx_tensor \\n&quot;, dx_tensor.data.numpy())<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"map\">5. mAP</h4>\n<h5 id=\"python-3\">python</h5>\n<h5 id=\"c-3\">c++</h5>\n<h4 id=\"softnms\">6. softnms</h4>\n<h5 id=\"python-4\">python</h5>\n<h6 id=\"版本1\">版本1</h6>\n<h1 id=\"soft_nms操作这里假设boxes是无序未按score做降序的所以每轮soft_nms迭代都需要类似冒泡排序操作选择当前top-1-bbox做nms\">soft_nms操作，这里假设boxes是无序(未按score做降序)的，所以每轮soft_nms迭代都需要类似冒泡排序操作，选择当前top-1 bbox做NMS</h1>\n<h1 id=\"nt计算iou的阈值iou-nt对应bbox的score权重就要降低\">Nt：计算IoU的阈值，IoU &gt; Nt，对应bbox的score权重就要降低</h1>\n<h1 id=\"threshold降权后通过threshold进一步剔除低权重bbox\">threshold：降权后通过threshold进一步剔除低权重bbox</h1>\n<p>def cpu_soft_nms(boxes, sigma=0.5, Nt=0.3, threshold=0.001, method=0): N = boxes.shape[0] for i in range(N): maxscore = boxes[i, 4] # 获取当前index下的bbox maxpos = i</p>\n<pre><code>    tx1 = boxes[i, 0]\n    ty1 = boxes[i, 1]\n    tx2 = boxes[i, 2]\n    ty2 = boxes[i, 3]\n    ts = boxes[i, 4]\n\n    pos = i + 1  # 下面操作就很常规了，找到当前index i之后所有bboxes中，score最大的bbox，并将之赋值给maxscore、maxpos\n    while pos &lt; N:\n        if maxscore &lt; boxes[pos, 4]:\n            maxscore = boxes[pos, 4]\n            maxpos = pos\n        pos = pos + 1\n\n    # 下面操作更简单，想想我们最开始学C语言，a、b两变量如何交换\n    # add max box as a detection\n    boxes[i, 0] = boxes[maxpos, 0]  # maxpos内的信息，放到index i处，也是当前需要处理的bbox\n    boxes[i, 1] = boxes[maxpos, 1]\n    boxes[i, 2] = boxes[maxpos, 2]\n    boxes[i, 3] = boxes[maxpos, 3]\n    boxes[i, 4] = boxes[maxpos, 4]\n\n    # swap ith box with position of max box\n    boxes[maxpos, 0] = tx1  # 别忘了tx1中可是保存了boxes[i,0]备份的\n    boxes[maxpos, 1] = ty1\n    boxes[maxpos, 2] = tx2\n    boxes[maxpos, 3] = ty2\n    boxes[maxpos, 4] = ts\n\n    tx1 = boxes[i, 0]  # 此时tx1就保存的maxpos位置的bbox信息了\n    ty1 = boxes[i, 1]\n    tx2 = boxes[i, 2]\n    ty2 = boxes[i, 3]\n    ts = boxes[i, 4]\n\n    pos = i + 1\n    # NMS iterations, note that N changes if detection boxes fall below threshold，N值是动态变化的\n    while pos &lt; N:  # 向后做NMS比较\n        x1 = boxes[pos, 0]  # 当前位置的bbox\n        y1 = boxes[pos, 1]\n        x2 = boxes[pos, 2]\n        y2 = boxes[pos, 3]\n        s = boxes[pos, 4]\n\n        area = (x2 - x1 + 1) * (y2 - y1 + 1)  # pos下box的面积\n        iw = (min(tx2, x2) - max(tx1, x1) + 1)  # 计算Insection的宽iw，如果iw &lt; 0，说明没相交，可以直接忽略了\n        if iw &gt; 0:\n            ih = (min(ty2, y2) - max(ty1, y1) + 1)  # 计算Insection的宽ih，如果ih &lt; 0，说明没相交，可以直接忽略了\n            if ih &gt; 0:\n                ua = float((tx2 - tx1 + 1) * (ty2 - ty1 + 1) + area - iw * ih)  # U的面积\n                ov = iw * ih / ua  # iou between max box and detection box\n\n                if method == 1:  # soft_nms中linear降权操作，与ov负相关\n                    if ov &gt; Nt:\n                        weight = 1 - ov\n                    else:\n                        weight = 1\n                elif method == 2:  # soft_nms中gaussian降权操作\n                    weight = np.exp(-(ov * ov) / sigma)\n                else:  # original NMS，weight = 0就直接把score置0\n                    if ov &gt; Nt:\n                        weight = 0\n                    else:\n                        weight = 1\n\n                boxes[pos, 4] = weight * boxes[pos, 4]  # 权重重新调整\n\n                # if box score falls below threshold, discard the box by swapping with last box，update N\n                # 如果bbox调整后的权重，已经小于阈值threshold，那么这个bbox就可以忽略了，\n                # 操作方式是直接用最后一个有效的bbox替换当前pos上的bbox\n                if boxes[pos, 4] &lt; threshold:\n                    boxes[pos, 0] = boxes[N - 1, 0]\n                    boxes[pos, 1] = boxes[N - 1, 1]\n                    boxes[pos, 2] = boxes[N - 1, 2]\n                    boxes[pos, 3] = boxes[N - 1, 3]\n                    boxes[pos, 4] = boxes[N - 1, 4]\n                    N = N - 1  # N-1位置上的bbox已经赋值到前面了，该bbox就可以忽略了；\n                    pos = pos - 1  # pos位置上引入了新的有效bbox(N-1)，就需要再计算一遍了\n\n        pos = pos + 1  # 当前pos bbox计算完毕\n\n# 求满足soft_nms筛选条件的所有bbox数量，并打散为list，但一个问题是：如何与bbox index对应起来？\n# 方式很简单，bbox也做了对应的调整、筛选，bbox list中top-N就对应着最高score，且soft-nms筛选通过的bbox，\n# 不过每个bbox的score也同样经过soft-nms调整了\nkeep = [i for i in range(N)]\n\nreturn keep</code></pre>\n<h6 id=\"版本2\">版本2</h6>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">def py_cpu_softnms(dets, sc, Nt&#x3D;0.3, sigma&#x3D;0.5, thresh&#x3D;0.001, method&#x3D;2):\n    &quot;&quot;&quot;\n    py_cpu_softnms\n    :param dets:   boexs 坐标矩阵 format [y1, x1, y2, x2]\n    :param sc:     每个 boxes 对应的分数\n    :param Nt:     iou 交叠门限\n    :param sigma:  使用 gaussian 函数的方差\n    :param thresh: 最后的分数门限\n    :param method: 使用的方法\n    :return:       留下的 boxes 的 index\n    &quot;&quot;&quot;\n\n    # indexes concatenate boxes with the last column\n    N &#x3D; dets.shape[0]\n    indexes &#x3D; np.array([np.arange(N)])\n    dets &#x3D; np.concatenate((dets, indexes.T), axis&#x3D;1)\n\n    # the order of boxes coordinate is [y1,x1,y2,x2]\n    y1 &#x3D; dets[:, 0]\n    x1 &#x3D; dets[:, 1]\n    y2 &#x3D; dets[:, 2]\n    x2 &#x3D; dets[:, 3]\n    scores &#x3D; sc\n    areas &#x3D; (x2 - x1 + 1) * (y2 - y1 + 1)\n\n    for i in range(N):\n        # intermediate parameters for later parameters exchange\n        tBD &#x3D; dets[i, :].copy()\n        tscore &#x3D; scores[i].copy()\n        tarea &#x3D; areas[i].copy()\n        pos &#x3D; i + 1\n\n        #\n        if i !&#x3D; N-1:\n            maxscore &#x3D; np.max(scores[pos:], axis&#x3D;0)\n            maxpos &#x3D; np.argmax(scores[pos:], axis&#x3D;0)\n        else:\n            maxscore &#x3D; scores[-1]\n            maxpos &#x3D; 0\n        if tscore &lt; maxscore:\n            dets[i, :] &#x3D; dets[maxpos + i + 1, :]\n            dets[maxpos + i + 1, :] &#x3D; tBD\n            tBD &#x3D; dets[i, :]\n\n            scores[i] &#x3D; scores[maxpos + i + 1]\n            scores[maxpos + i + 1] &#x3D; tscore\n            tscore &#x3D; scores[i]\n\n            areas[i] &#x3D; areas[maxpos + i + 1]\n            areas[maxpos + i + 1] &#x3D; tarea\n            tarea &#x3D; areas[i]\n\n        # IoU calculate\n        xx1 &#x3D; np.maximum(dets[i, 1], dets[pos:, 1])\n        yy1 &#x3D; np.maximum(dets[i, 0], dets[pos:, 0])\n        xx2 &#x3D; np.minimum(dets[i, 3], dets[pos:, 3])\n        yy2 &#x3D; np.minimum(dets[i, 2], dets[pos:, 2])\n\n        w &#x3D; np.maximum(0.0, xx2 - xx1 + 1)\n        h &#x3D; np.maximum(0.0, yy2 - yy1 + 1)\n        inter &#x3D; w * h\n        ovr &#x3D; inter &#x2F; (areas[i] + areas[pos:] - inter)\n\n        # Three methods: 1.linear 2.gaussian 3.original NMS\n        if method &#x3D;&#x3D; 1:  # linear\n            weight &#x3D; np.ones(ovr.shape)\n            weight[ovr &gt; Nt] &#x3D; weight[ovr &gt; Nt] - ovr[ovr &gt; Nt]\n        elif method &#x3D;&#x3D; 2:  # gaussian\n            weight &#x3D; np.exp(-(ovr * ovr) &#x2F; sigma)\n        else:  # original NMS\n            weight &#x3D; np.ones(ovr.shape)\n            weight[ovr &gt; Nt] &#x3D; 0\n\n        scores[pos:] &#x3D; weight * scores[pos:]\n\n    # select the boxes and keep the corresponding indexes\n    inds &#x3D; dets[:, 4][scores &gt; thresh]\n    keep &#x3D; inds.astype(int)\n\n    return keep<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">def test():\n    # boxes and scores\n    boxes &#x3D; np.array([[200, 200, 400, 400], [220, 220, 420, 420], [200, 240, 400, 440], [240, 200, 440, 400], [1, 1, 2, 2]], dtype&#x3D;np.float32)\n    boxscores &#x3D; np.array([0.9, 0.8, 0.7, 0.6, 0.5], dtype&#x3D;np.float32)\n    index &#x3D; py_cpu_softnms(boxes, boxscores, method&#x3D;3)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"c-4\">c++</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n#include &lt;bits&#x2F;stdc++.h&gt;\n\nnamespace nms\n&#123;\nstruct proposal\n&#123;\n  float score, x1, y1, x2, y2;\n&#125;;\n\ninline static bool cmp(const proposal&amp; a, const proposal&amp; b)\n&#123;\n  return a.score &lt; b.score;\n&#125;\n\ninline static float iou(const proposal&amp;, const proposal&amp;) __attribute__((always_inline));\n\nstatic float iou(const proposal&amp; a, const proposal&amp; b)\n&#123;\n  auto overlap &#x3D; 0.f;\n  float iw  &#x3D; std::min(b.x2, a.x2) - std::max(b.x1, a.x1) + 1;\n  if (iw &gt; 0) &#123;\n    float ih &#x3D; std::min(b.y2, a.y2) - std::max(b.y1, a.y1) + 1;\n    if (ih &gt; 0) &#123;\n      float ab &#x3D; (b.x2 - b.x1 + 1) * (b.y2 - b.y1 + 1);\n      float aa &#x3D; (a.x2 - a.x1 + 1) * (a.y2 - a.y1 + 1);\n      float inter &#x3D; iw * ih;\n      overlap &#x3D; inter &#x2F; (aa + ab - inter);\n    &#125;\n  &#125;\n  return overlap;\n&#125;\n\nenum class Method : uint32_t\n&#123;\n  LINEAR &#x3D; 0,\n  GAUSSIAN,\n  HARD\n&#125;;\n\nsize_t soft_nms(float* boxes,\n                int32_t* index,\n                size_t count,\n                Method method,\n                float Nt,\n                float sigma,\n                float threshold)\n&#123;\n  std::iota(index, index + count, 0);  &#x2F;&#x2F; np.arange()\n  auto p &#x3D; reinterpret_cast&lt;proposal*&gt;(boxes);\n\n  auto N &#x3D; count;\n  for (size_t i &#x3D; 0; i &lt; N; ++i) &#123;\n    auto max &#x3D; std::max_element(p + i, p + N, cmp);\n    std::swap(p[i], *max);\n    std::swap(index[i], index[max - p]);\n\n    auto j      &#x3D; i + 1;\n    auto weight &#x3D; 0.f;\n    while (j &lt; N) &#123;\n      auto ov &#x3D; iou(p[i], p[j]);\n      switch (method) &#123;\n        case Method::LINEAR:\n          weight &#x3D; ov &gt; Nt ? 1.f - ov : 1.f;\n          break;\n        case Method::GAUSSIAN:\n          weight &#x3D; std::exp(-(ov * ov) &#x2F; sigma);\n          break;\n        case Method::HARD:\n          weight &#x3D; ov &gt; Nt ? 0.f : 1.f;\n          break;\n      &#125;\n      p[j].score *&#x3D; weight;\n      if (p[j].score &lt; threshold) &#123;\n        N--;\n        std::swap(p[j], p[N]);\n        std::swap(index[j], index[N]);\n        j--;\n      &#125;\n      j++;\n    &#125;\n  &#125;;\n\n  return N;\n&#125;\n&#125; &#x2F;* namespace nms *&#x2F;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"实现one-hot特征\">7. 实现one-hot特征</h4>\n<h5 id=\"python-5\">python</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">one_hot_t&#x3D; np.zeros_like(y)  #生成和y形状一样的元素为零的数组\nfor j, i in zip(range(t.size), t):\n    #有多少个样本就应该对应多少个标签\n    one_hot_t[j][i] &#x3D; 1      #变为one-hot类型标签：j表示样本，i表示标签索引\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"softmax\">8. softmax</h4>\n<h5 id=\"python-6\">python</h5>\n<p>由于指数函数的放大作用过于明显，如果直接使用softmax计算公式𝑠𝑜𝑓𝑡𝑚𝑎𝑥(𝑥𝑖)=𝑒𝑥𝑝(𝑥𝑖)/∑𝑒𝑥𝑝(𝑥𝑗)进行函数实现，容易导致数据溢出(上溢)。所以我们在函数实现时利用其性质：先对输入数据进行处理，之后再利用计算公式计算。具体使得实现步骤为： 查找每个向量x的最大值c； 每个向量减去其最大值c, 得到向量y = x-c; 利用公式进行计算,softmax(x) = softmax(x-c) = softmax(y)</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import numpy as np\n\ndef softmax(x: np.array):\n    x_max &#x3D; np.max(x, axis&#x3D;-1, keepdims&#x3D;True)\n    x -&#x3D; x_max\n    x_exp &#x3D; np.exp(x)\n    s &#x3D; x_exp &#x2F; np.sum(x_exp, axis&#x3D;-1, keepdims&#x3D;True)\n    return s\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"各种滤波\">9. 各种滤波</h4>\n<h5 id=\"马赛克\">马赛克</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">mport cv2\n\n\n##马赛克\ndef do_mosaic(frame, x, y, w, h, neighbor&#x3D;9):\n    &quot;&quot;&quot;\n    马赛克的实现原理是把图像上某个像素点一定范围邻域内的所有点用邻域内左上像素点的颜色代替，这样可以模糊细节，但是可以保留大体的轮廓。\n    :param frame: opencv frame\n    :param int x :  马赛克左顶点\n    :param int y:  马赛克右顶点\n    :param int w:  马赛克宽\n    :param int h:  马赛克高\n    :param int neighbor:  马赛克每一块的宽\n    &quot;&quot;&quot;\n    fh, fw &#x3D; frame.shape[0], frame.shape[1]\n    if (y + h &gt; fh) or (x + w &gt; fw):\n        return\n    for i in range(0, h - neighbor, neighbor):  # 关键点0 减去neightbour 防止溢出\n        for j in range(0, w - neighbor, neighbor):\n            rect &#x3D; [j + x, i + y, neighbor, neighbor]\n            color &#x3D; frame[i + y][j + x].tolist()  # 关键点1 tolist\n            left_up &#x3D; (rect[0], rect[1])\n            right_down &#x3D; (rect[0] + neighbor - 1, rect[1] + neighbor - 1)  # 关键点2 减去一个像素\n            cv2.rectangle(frame, left_up, right_down, color, -1)\n\n\nim &#x3D; cv2.imread(&#39;test.jpg&#39;, 1)\ndo_mosaic(im, 219, 61, 460 - 219, 412 - 61)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"高斯滤波\">高斯滤波</h5>\n<p><a href=\"https://www.cnblogs.com/wojianxin/p/12498391.html\">出处</a> <pre class=\"line-numbers language-none\"><code class=\"language-none\">import cv2\n\nimport numpy as np\n\n# Gaussian filter\n\ndef gaussian_filter(img, K_size&#x3D;3, sigma&#x3D;1.3):\n\n    if len(img.shape) &#x3D;&#x3D; 3:\n\n        H, W, C &#x3D; img.shape\n\n    else:\n\n        img &#x3D; np.expand_dims(img, axis&#x3D;-1)\n\n        H, W, C &#x3D; img.shape\n\n    ## Zero padding\n\n    pad &#x3D; K_size &#x2F;&#x2F; 2\n\n    out &#x3D; np.zeros((H + pad * 2, W + pad * 2, C), dtype&#x3D;np.float)\n\n    out[pad: pad + H, pad: pad + W] &#x3D; img.copy().astype(np.float)\n\n    ## prepare Kernel\n\n    K &#x3D; np.zeros((K_size, K_size), dtype&#x3D;np.float)\n\n    for x in range(-pad, -pad + K_size):\n\n        for y in range(-pad, -pad + K_size):\n\n            K[y + pad, x + pad] &#x3D; np.exp( -(x ** 2 + y ** 2) &#x2F; (2 * (sigma ** 2)))\n\n    K &#x2F;&#x3D; (2 * np.pi * sigma * sigma)\n\n    K &#x2F;&#x3D; K.sum()\n\n    tmp &#x3D; out.copy()\n\n    # filtering\n\n    for y in range(H):\n\n        for x in range(W):\n\n            for c in range(C):\n\n                out[pad + y, pad + x, c] &#x3D; np.sum(K * tmp[y: y + K_size, x: x + K_size, c])\n\n    out &#x3D; np.clip(out, 0, 255)\n\n    out &#x3D; out[pad: pad + H, pad: pad + W].astype(np.uint8)\n\n    return out\n\n# Read image\n\nimg &#x3D; cv2.imread(&quot;..&#x2F;paojie.jpg&quot;)\n\n# Gaussian Filter\n\nout &#x3D; gaussian_filter(img, K_size&#x3D;3, sigma&#x3D;1.3)\n\n# Save result\n\ncv2.imwrite(&quot;out.jpg&quot;, out)\n\ncv2.imshow(&quot;result&quot;, out)\n\ncv2.waitKey(0)\n\ncv2.destroyAllWindows()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> ##### 均值滤波</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import numpy as np\n\n\ndef means_filter(input_image, filter_size):\n    &#39;&#39;&#39;\n    均值滤波器\n    :param input_image: 输入图像\n    :param filter_size: 滤波器大小\n    :return: 输出图像\n\n    注：此实现滤波器大小必须为奇数且 &gt;&#x3D; 3\n    &#39;&#39;&#39;\n    input_image_cp &#x3D; np.copy(input_image)  # 输入图像的副本\n\n    filter_template &#x3D; np.ones((filter_size, filter_size))  # 空间滤波器模板\n\n    pad_num &#x3D; int((filter_size - 1) &#x2F; 2)  # 输入图像需要填充的尺寸\n\n    input_image_cp &#x3D; np.pad(input_image_cp, (pad_num, pad_num), mode&#x3D;&quot;constant&quot;, constant_values&#x3D;0)  # 填充输入图像\n\n    m, n &#x3D; input_image_cp.shape  # 获取填充后的输入图像的大小\n\n    output_image &#x3D; np.copy(input_image_cp)  # 输出图像\n\n    # 空间滤波\n    for i in range(pad_num, m - pad_num):\n        for j in range(pad_num, n - pad_num):\n            output_image[i, j] &#x3D; np.sum(filter_template * input_image_cp[i - pad_num:i + pad_num + 1, j - pad_num:j + pad_num + 1]) &#x2F; (filter_size ** 2)\n\n    output_image &#x3D; output_image[pad_num:m - pad_num, pad_num:n - pad_num]  # 裁剪\n\n    return output_image<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"中值滤波\">中值滤波</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"># 中值滤波#\nimport cv2\nimport numpy as np\n\ndef MedianFilter(img,k&#x3D;3,padding&#x3D;None):\n    imarray&#x3D;img\n    height &#x3D; imarray.shape[0]\n    width &#x3D; imarray.shape[1]\n    if not padding:\n        edge &#x3D; int((k - 1) &#x2F; 2)\n        if height - 1 - edge &lt;&#x3D; edge or width - 1 - edge &lt;&#x3D; edge:\n            print(&quot;The parameter k is to large.&quot;)\n            return None\n        new_arr &#x3D; np.zeros((height, width), dtype&#x3D;&quot;uint8&quot;)\n        for i in range(edge,height-edge):\n            for j in range(edge,width-edge):\n                new_arr[i, j] &#x3D; np.median(imarray[i - edge:i + edge + 1, j - edge:j + edge + 1])# 调用np.median求取中值\n    return new_arr\n\n\nimg &#x3D; cv2.imread(&quot;salt—cat.jpg&quot;, 0)\nresult &#x3D; MedianFilter(img)\ncv2.imwrite(&#39;re-cat.jpg&#39;, result)\n# median3 &#x3D; cv2.medianBlur(result, 3)\n# median5 &#x3D; cv2.medianBlur(result, 5)\ncv2.imshow(&quot;input&quot;, img)\ncv2.imshow(&quot;output&quot;, result)\n# cv2.imshow(&quot;Median3&quot;, median3)\n# cv2.imshow(&quot;Median5&quot;, median5)\ncv2.waitKey(0)\ncv2.destroyAllWindows()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"kmeans\">Kmeans</h4>\n<p>https://zhuanlan.zhihu.com/p/35959301 #### 积分图均值滤波 https://blog.csdn.net/weixin_40647819/article/details/88775598</p>\n","feature":true,"text":"1. IOU python def bb_intersection_over_union(boxA, boxB): boxA &#x3D; [int(x) for x in boxA] boxB &#x3D; [int(x) for x in boxB] xA &#x3D; ma...","link":"","photos":[],"count_time":{"symbolsCount":"28k","symbolsTime":"26 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#iou\"><span class=\"toc-text\">1. IOU</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#python\"><span class=\"toc-text\">python</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#c\"><span class=\"toc-text\">c++</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#nms\"><span class=\"toc-text\">2. NMS</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#python-1\"><span class=\"toc-text\">python</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#c-1\"><span class=\"toc-text\">c++</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8D%B7%E7%A7%AF\"><span class=\"toc-text\">3. 卷积</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#python-2\"><span class=\"toc-text\">python</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#c-2\"><span class=\"toc-text\">c++</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#pooling\"><span class=\"toc-text\">4. Pooling</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#maxpooling\"><span class=\"toc-text\">maxpooling</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E7%89%88%E6%9C%AC1%E7%AE%80%E5%8D%95%E7%89%88\"><span class=\"toc-text\">版本1(简单版)</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E7%89%88%E6%9C%AC2%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD\"><span class=\"toc-text\">版本2(反向传播)</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#avg-pooling\"><span class=\"toc-text\">avg-pooling</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E7%89%88%E6%9C%AC1%E7%AE%80%E5%8D%95%E7%89%88-1\"><span class=\"toc-text\">版本1(简单版)</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E7%89%88%E6%9C%AC2%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD-1\"><span class=\"toc-text\">版本2(反向传播)</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#map\"><span class=\"toc-text\">5. mAP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#python-3\"><span class=\"toc-text\">python</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#c-3\"><span class=\"toc-text\">c++</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#softnms\"><span class=\"toc-text\">6. softnms</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#python-4\"><span class=\"toc-text\">python</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E7%89%88%E6%9C%AC1\"><span class=\"toc-text\">版本1</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#soft_nms%E6%93%8D%E4%BD%9C%E8%BF%99%E9%87%8C%E5%81%87%E8%AE%BEboxes%E6%98%AF%E6%97%A0%E5%BA%8F%E6%9C%AA%E6%8C%89score%E5%81%9A%E9%99%8D%E5%BA%8F%E7%9A%84%E6%89%80%E4%BB%A5%E6%AF%8F%E8%BD%AEsoft_nms%E8%BF%AD%E4%BB%A3%E9%83%BD%E9%9C%80%E8%A6%81%E7%B1%BB%E4%BC%BC%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C%E9%80%89%E6%8B%A9%E5%BD%93%E5%89%8Dtop-1-bbox%E5%81%9Anms\"><span class=\"toc-text\">soft_nms操作，这里假设boxes是无序(未按score做降序)的，所以每轮soft_nms迭代都需要类似冒泡排序操作，选择当前top-1 bbox做NMS</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#nt%E8%AE%A1%E7%AE%97iou%E7%9A%84%E9%98%88%E5%80%BCiou-nt%E5%AF%B9%E5%BA%94bbox%E7%9A%84score%E6%9D%83%E9%87%8D%E5%B0%B1%E8%A6%81%E9%99%8D%E4%BD%8E\"><span class=\"toc-text\">Nt：计算IoU的阈值，IoU &gt; Nt，对应bbox的score权重就要降低</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#threshold%E9%99%8D%E6%9D%83%E5%90%8E%E9%80%9A%E8%BF%87threshold%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%89%94%E9%99%A4%E4%BD%8E%E6%9D%83%E9%87%8Dbbox\"><span class=\"toc-text\">threshold：降权后通过threshold进一步剔除低权重bbox</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E7%89%88%E6%9C%AC2\"><span class=\"toc-text\">版本2</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#c-4\"><span class=\"toc-text\">c++</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0one-hot%E7%89%B9%E5%BE%81\"><span class=\"toc-text\">7. 实现one-hot特征</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#python-5\"><span class=\"toc-text\">python</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#softmax\"><span class=\"toc-text\">8. softmax</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#python-6\"><span class=\"toc-text\">python</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%90%84%E7%A7%8D%E6%BB%A4%E6%B3%A2\"><span class=\"toc-text\">9. 各种滤波</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%A9%AC%E8%B5%9B%E5%85%8B\"><span class=\"toc-text\">马赛克</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%AB%98%E6%96%AF%E6%BB%A4%E6%B3%A2\"><span class=\"toc-text\">高斯滤波</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2\"><span class=\"toc-text\">中值滤波</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#kmeans\"><span class=\"toc-text\">Kmeans</span></a></li></ol>","author":{"name":"Hulk Wang","slug":"blog-author","avatar":"/images/avatar_small.jpg","link":"https://github.com/TalkUHulk","description":"I'm 浩克，CV算法工程师，热衷于各种有趣的技术，此博客主要用来做学习总结，杀死拖延症。<br /> <img src=\"/images/funny.gif\" height=\"240\" width=\"360\"/>","socials":{"github":"https://github.com/TalkUHulk","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/311127773","zhihu":"https://www.zhihu.com/people/MisterAntebellum","csdn":"https://blog.csdn.net/hyqwmxsh","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"CV面试基础总结","uid":"2d84f3892209cec11720cffbf464a897","slug":"CV面试基础总结","date":"2021-10-12T07:57:22.000Z","updated":"2021-10-27T02:54:44.304Z","comments":true,"path":"api/articles/CV面试基础总结.json","keywords":null,"cover":[],"text":"1. 评测指标 1.1 基本概念 TP TN FP FN T-Ture;F-False 表示预测结果的正确性，T表示预测正确，F表示预测错误； P-positive;N-negative 表示预测的正负性，P表示预测为正样本，N表示预测为负样本； --- --- TP——True...","link":"","photos":[],"count_time":{"symbolsCount":"44k","symbolsTime":"40 mins."},"categories":[],"tags":[{"name":"面试基础","slug":"面试基础","count":1,"path":"api/tags/面试基础.json"}],"author":{"name":"Hulk Wang","slug":"blog-author","avatar":"/images/avatar_small.jpg","link":"https://github.com/TalkUHulk","description":"I'm 浩克，CV算法工程师，热衷于各种有趣的技术，此博客主要用来做学习总结，杀死拖延症。<br /> <img src=\"/images/funny.gif\" height=\"240\" width=\"360\"/>","socials":{"github":"https://github.com/TalkUHulk","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/311127773","zhihu":"https://www.zhihu.com/people/MisterAntebellum","csdn":"https://blog.csdn.net/hyqwmxsh","juejin":"","customs":{}}},"feature":true}}