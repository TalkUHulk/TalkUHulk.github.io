{"title":"æ‰‹æ’•ä»£ç ","uid":"66e6fbbf30cdfd5fb293d5ee17ed3935","slug":"æ‰‹æ’•ä»£ç ","date":"2021-10-19T03:41:08.000Z","updated":"2021-10-30T03:54:24.199Z","comments":true,"path":"api/articles/æ‰‹æ’•ä»£ç .json","keywords":null,"cover":[],"content":"<h4 id=\"iou\">1. IOU</h4>\n<h5 id=\"python\">python</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">def bb_intersection_over_union(boxA, boxB):\n    boxA = [int(x) for x in boxA]\n    boxB = [int(x) for x in boxB]\n\n    xA = max(boxA[0], boxB[0])\n    yA = max(boxA[1], boxB[1])\n    xB = min(boxA[2], boxB[2])\n    yB = min(boxA[3], boxB[3])\n\n    interArea = max(0, xB - xA + 1) * max(0, yB - yA + 1)\n\n    boxAArea = (boxA[2] - boxA[0] + 1) * (boxA[3] - boxA[1] + 1)\n    boxBArea = (boxB[2] - boxB[0] + 1) * (boxB[3] - boxB[1] + 1)\n    \n    iou = interArea / float(boxAArea + boxBArea - interArea)\n\n    return iou<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"c\">c++</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\ntypedef struct Bbox\n{\n    int x1;\n    int y1;\n    int x2;\n    int y2;\n    float score;\n}Bbox;\n\nfloat iou(Bbox box1,Bbox box2)\n{\n    max_x = max(box1.x1,box2.x1);  // æ‰¾å‡ºå·¦ä¸Šè§’åæ ‡å“ªä¸ªå¤§\n    min_x = min(box1.x2,box2.x2);  // æ‰¾å‡ºå³ä¸Šè§’åæ ‡å“ªä¸ªå°\n    max_y = max(box1.y1,box2.y1);\n    min_y = min(box1.y2,box2.y2);\n    if(min_x&lt;=max_x || min_y&lt;=max_y) // å¦‚æœæ²¡æœ‰é‡å \n        return 0;\n    float over_area = (min_x - max_x) * (min_y - max_y);  // è®¡ç®—é‡å é¢ç§¯\n    float area_a = (box1.x2 - boxa.x1) * (box1.y2 - boxa.y1);\n    float area_b = (box2.x2 - boxb.x1) * (box2.y2 - boxb.y1);\n    float iou = over_area / (area_a + area_b - over_area);\n    return iou;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"nms\">2. NMS</h4>\n<h5 id=\"python-1\">python</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">def nms(det, thresh):\n    x1 = det[..., 0]\n    y1 = det[..., 1]\n    x2 = det[..., 2]\n    y2 = det[..., 3]\n    scores = det[..., 4]\n    area = (x2 - x1 + 1) * (y2 - y1 + 1)\n    order = np.argsort(scores)[::-1]  # Returns the indices that would sort an array.\n    keep = []\n    while order.size &gt; 0:\n        i = order[0]\n        keep.append(i)\n        xx1 = np.maximum(x1[i], x1[order[1:]])\n        yy1 = np.maximum(y1[i], y1[order[1:]])\n        xx2 = np.minimum(x2[i], x2[order[1:]])\n        yy2 = np.minimum(x2[i], x2[order[1:]])\n        w = np.maximum(0, xx2 - xx1 + 1)\n        h = np.maximum(0, yy2 - yy1 + 1)\n        inter = w * h\n        union = area[i] + area[order[1:]] - inter\n        iou = inter / union\n        next_i = np.where(iou &lt;= thresh)[0]  # åªæœ‰æ¡ä»¶ (condition)ï¼Œæ²¡æœ‰xå’Œyï¼Œåˆ™è¾“å‡ºæ»¡è¶³æ¡ä»¶ (å³é0) å…ƒç´ çš„åæ ‡\n        order = order[next_i + 1]\n    return keep<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"c-1\">c++</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">/*\n  å°†bbxæŒ‰ç…§confidenceä»é«˜åˆ°ä½æ’åº\n*/\nbool sort_score(Bbox box1,Bbox box2)\n{\n    return (box1.score &gt; box2.score);\n}\n/*\n(1) è·å–å½“å‰ç›®æ ‡ç±»åˆ«ä¸‹æ‰€æœ‰bbxçš„ä¿¡æ¯\n(2) å°†bbxæŒ‰ç…§confidenceä»é«˜åˆ°ä½æ’åº,å¹¶è®°å½•å½“å‰confidenceæœ€å¤§çš„bbx\n(3) è®¡ç®—æœ€å¤§confidenceå¯¹åº”çš„bbxä¸å‰©ä¸‹æ‰€æœ‰çš„bbxçš„IOU,ç§»é™¤æ‰€æœ‰å¤§äºIOUé˜ˆå€¼çš„bbx\n(4) å¯¹å‰©ä¸‹çš„bbxï¼Œå¾ªç¯æ‰§è¡Œ(2)å’Œ(3)ç›´åˆ°æ‰€æœ‰çš„bbxå‡æ»¡è¶³è¦æ±‚ï¼ˆå³ä¸èƒ½å†ç§»é™¤bbxï¼‰\n*/\nvector&lt;Bbox&gt; nms(vector&lt;Bbox&gt;&amp;vec_boxs, float threshold)\n{\n    vector&lt;Bbox&gt;  res;\n    while(vec_boxs.size() &gt; 0)\n    {\n        sort(vec_boxs.begin(),vec_boxs.end(),cmp);\n        res.push_back(vec_boxs[0]);\n        for(int i =0;i &lt;vec_boxs.size()-1;i++)\n        {\n            float iou_value =iou(vec_boxs[0],vec_boxs[i+1]);\n            if (iou_value &gt;threshold)\n            {\n                vec_boxs.erase(vec_boxs[i+1]);\n            }\n        }\n        vec_boxs.erase(vec_boxs[0]);  // res å·²ç»ä¿å­˜ï¼Œæ‰€ä»¥å¯ä»¥å°†æœ€å¤§çš„åˆ é™¤äº†\n \n    }\n    return res;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"å·ç§¯\">3. å·ç§¯</h4>\n<h5 id=\"python-2\">python</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">def conv_naive(x, c_out, ksize=3, padding=0, stride=1):\n    b, c_in, h, w = x.shape\n    kernel = np.random.rand(c_out, c_in, ksize, ksize)\n    out_height = (h - ksize + 2 * padding) // stride + 1\n    out_width = (w - ksize + 2 * padding) // stride + 1\n\n    out_x = np.random.rand(b, c_out, out_height,  out_width)\n    if padding &gt; 0:\n        pad_x = np.zeros((b, c_in, h + 2 * padding, w + 2 * padding))\n        pad_x[..., padding:-padding, padding:-padding] = x\n    else:\n        pad_x = x\n\n    for y in range(out_height):\n        for x in range(out_width):\n            roi = pad_x[..., y * stride:y * stride + ksize, x * stride: x * stride + ksize]\n            conv = np.tile(np.expand_dims(roi, axis=1), (1, c_out, 1, 1, 1)) * kernel\n            # conv = np.repeat(np.expand_dims(roi, axis=1), axis=1, repeats=c_out) * kernel\n            out_x[..., y, x] = np.squeeze(np.sum(conv, axis=(2, 3, 4), keepdims=True), axis=(2, 3, 4))\n\n    return out_x<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"c-2\">c++</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">/äºŒç»´å·ç§¯çš„å®ç°\n#include&lt;cassert&gt;\n#include&lt;vector&gt;\n\n\nvoid conv2(int** filter, int **mat, int** res, const int filter_rows, const int filter_cols, const int mat_rows, const int mat_cols);//æŒ‡é’ˆæ•°ç»„ç‰ˆæœ¬\nstd::vector&lt;std::vector&lt;int&gt; &gt; conv2(std::vector&lt;std::vector&lt;int&gt; &gt; filter, std::vector&lt;std::vector&lt;int&gt; &gt; mat);//å‘é‡ç‰ˆæœ¬\n\n\nint main(void)\n{\n    return 0;\n}//main\n\nvoid conv2(int** filter, int **mat, int** res, const int filter_rows, const int filter_cols, const int mat_rows, const int mat_cols)\n{\n    assert(filter_cols &lt; mat_cols &amp;&amp; filter_rows &lt; mat_rows);\n    for(int i = 0; i &lt; mat_rows - 1; ++i)\n        for (int j = 0; j &lt; mat_cols - 1; ++j)\n        {\n            int tmp = 0;\n            for (int m = 0; m &lt; filter_rows; ++m)\n                for (int n = 0; n &lt; filter_cols; ++n)\n                    if(0 &lt;= i -m  &amp;&amp; i - m &lt; mat_rows &amp;&amp; 0 &lt;= j - n &amp;&amp; j - n &lt; mat_cols)\n                        tmp += filter[m][n] * mat[i - m][j - n];//å·ç§¯å…¬å¼\n\n            res[i][j] = tmp;\n        }\n}\n\nstd::vector&lt;std::vector&lt;int&gt; &gt; conv2(std::vector&lt;std::vector&lt;int&gt; &gt; filter, std::vector&lt;std::vector&lt;int&gt; &gt; mat )//å‘é‡ç‰ˆæœ¬\n{\n    const int filter_rows = filter.size();\n    const int filter_cols = filter[0].size();\n\n    const int mat_rows = mat.size();\n    const int mat_cols = mat[0].size();\n\n    assert(filter_cols &lt; mat_cols &amp;&amp; filter_rows &lt; mat_rows);\n    std::vector&lt;std::vector&lt;int&gt; &gt; res(mat_rows, std::vector&lt;int&gt;(mat_cols, 0));\n\n    for (int i = 0; i &lt; mat_rows - 1; ++i)\n        for (int j = 0; j &lt; mat_cols - 1; ++j)\n        {\n            int tmp = 0;\n            for (int m = 0; m &lt; filter_rows; ++m)\n                for (int n = 0; n &lt; filter_cols; ++n)\n                    if (0 &lt;= i - m &amp;&amp; i - m &lt; mat_rows &amp;&amp; 0 &lt;= j - n &amp;&amp; j - n &lt; mat_cols)\n                        tmp += filter[m][n] * mat[i - m][j - n];//å·ç§¯å…¬å¼\n\n            res[i][j] = tmp;\n        }\n    return res;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"pooling\">4. Pooling</h4>\n<h5 id=\"maxpooling\">maxpooling</h5>\n<h6 id=\"ç‰ˆæœ¬1ç®€å•ç‰ˆ\">ç‰ˆæœ¬1(ç®€å•ç‰ˆ)</h6>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">def max_pooling(x, kernel_size=2, stride=2):\n    b, c_in, h, w = x.shape\n    ow = (w - kernel_size) // stride + 1\n    oh = (h - kernel_size) // stride + 1\n\n    out = np.zeros([b, c_in, oh, ow])\n    x_input = x\n    for y in range(oh):\n        for x in range(ow):\n            roi = x_input[..., y * stride: y * stride + kernel_size, x * stride: x * stride + kernel_size]\n            max_val = np.squeeze(np.max(roi, axis=(2, 3), keepdims=True), axis=(2, 3))\n            out[..., y, x] = max_val\n    return out<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h6 id=\"ç‰ˆæœ¬2åå‘ä¼ æ’­\">ç‰ˆæœ¬2(åå‘ä¼ æ’­)</h6>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import numpy as np\nimport torch\nclass MaxPooling2D:\n    def __init__(self, kernel_size=(2, 2), stride=2):\n        self.kernel_size = kernel_size\n        self.w_height = kernel_size[0]\n        self.w_width = kernel_size[1]\n\n        self.stride = stride\n\n        self.x = None\n        self.in_height = None\n        self.in_width = None\n\n        self.out_height = None\n        self.out_width = None\n\n        self.arg_max = None\n\n    def __call__(self, x):\n        self.x = x\n        self.in_height = np.shape(x)[0]\n        self.in_width = np.shape(x)[1]\n\n        self.out_height = int((self.in_height - self.w_height) / self.stride) + 1\n        self.out_width = int((self.in_width - self.w_width) / self.stride) + 1\n\n        out = np.zeros((self.out_height, self.out_width))\n        self.arg_max = np.zeros_like(out, dtype=np.int32)\n\n        for i in range(self.out_height):\n            for j in range(self.out_width):\n                start_i = i * self.stride\n                start_j = j * self.stride\n                end_i = start_i + self.w_height\n                end_j = start_j + self.w_width\n                out[i, j] = np.max(x[start_i: end_i, start_j: end_j])\n                self.arg_max[i, j] = np.argmax(x[start_i: end_i, start_j: end_j])\n        self.arg_max = self.arg_max\n        return out\n\n    def backward(self, d_loss):\n        dx = np.zeros_like(self.x)\n        for i in range(self.out_height):\n            for j in range(self.out_width):\n                start_i = i * self.stride\n                start_j = j * self.stride\n                end_i = start_i + self.w_height\n                end_j = start_j + self.w_width\n                index = np.unravel_index(self.arg_max[i, j], self.kernel_size)\n                dx[start_i:end_i, start_j:end_j][index] = d_loss[i, j] #\n        return dx<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>test</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">np.set_printoptions(precision=8, suppress=True, linewidth=120)\nx_numpy = np.random.random((1, 1, 6, 9))\nx_tensor = torch.tensor(x_numpy, requires_grad=True)\n\nmax_pool_tensor = torch.nn.MaxPool2d((2, 2), 2)\nmax_pool_numpy = MaxPooling2D((2, 2), stride=2)\n\nout_numpy = max_pool_numpy(x_numpy[0, 0])\nout_tensor = max_pool_tensor(x_tensor)\n\nd_loss_numpy = np.random.random(out_tensor.shape)\nd_loss_tensor = torch.tensor(d_loss_numpy, requires_grad=True)\nout_tensor.backward(d_loss_tensor)\n\ndx_numpy = max_pool_numpy.backward(d_loss_numpy[0, 0])\ndx_tensor = x_tensor.grad\n# print('input \\n', x_numpy)\nprint(\"out_numpy \\n\", out_numpy)\nprint(\"out_tensor \\n\", out_tensor.data.numpy())\n\nprint(\"dx_numpy \\n\", dx_numpy)\nprint(\"dx_tensor \\n\", dx_tensor.data.numpy())<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">def pooling(feature_map, size=2, stride=2):\n    channel=feature_map.shape[0]\n    height=feature_map.shape[1]\n    width=feature_map.shape[2]\n    padding_height=np.uint16(round((height-size+1)/stride))\n    padding_width=np.uint16(round((width-size+1)/stride))\n    print(padding_height,padding_width)\n\n    pool_out = np.zeros((channel,padding_height,padding_width),dtype=np.uint8)\n    \n    for map_num in range(channel):  \n        out_height = 0  \n        for r in np.arange(0,height, stride):  \n            out_width = 0  \n            for c in np.arange(0, width, stride):  \n                pool_out[map_num,out_height, out_width] = np.max(feature_map[map_num,r:r+size,c:c+size])  \n                out_width=out_width+1\n            out_height=out_height+1\n    return pool_out<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"avg-pooling\">avg-pooling</h5>\n<h6 id=\"ç‰ˆæœ¬1ç®€å•ç‰ˆ-1\">ç‰ˆæœ¬1(ç®€å•ç‰ˆ)</h6>\n<p>def avg_pooling(x, kernel_size=2, stride=2): b, c_in, h, w = x.shape ow = (w - kernel_size) // stride + 1 oh = (h - kernel_size) // stride + 1</p>\n<pre><code>out = np.zeros([b, c_in, oh, ow])\nx_input = x\nfor y in range(oh):\n    for x in range(ow):\n        roi = x_input[..., y * stride: y * stride + kernel_size, x * stride: x * stride + kernel_size]\n        max_val = np.average(roi, axis=(2, 3))\n        out[..., y, x] = max_val\nreturn out</code></pre>\n<h6 id=\"ç‰ˆæœ¬2åå‘ä¼ æ’­-1\">ç‰ˆæœ¬2(åå‘ä¼ æ’­)</h6>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import numpy as np\nimport torch\n\nclass AvgPooling2D:\n    def __init__(self, kernel_size=(2, 2), stride=2):\n        self.stride = stride\n        self.kernel_size = kernel_size\n        self.w_height = kernel_size[0]\n        self.w_width = kernel_size[1]\n\n    def __call__(self, x):\n        self.x = x\n        self.in_height = x.shape[0]\n        self.in_width = x.shape[1]\n\n        self.out_height = int((self.in_height - self.w_height) / self.stride) + 1\n        self.out_width = int((self.in_width - self.w_width) / self.stride) + 1\n        out = np.zeros((self.out_height, self.out_width))\n\n        for i in range(self.out_height):\n            for j in range(self.out_width):\n                start_i = i * self.stride\n                start_j = j * self.stride\n                end_i = start_i + self.w_height\n                end_j = start_j + self.w_width\n                out[i, j] = np.mean(x[start_i: end_i, start_j: end_j])\n        return out\n\n    def backward(self, d_loss):\n        dx = np.zeros_like(self.x)\n\n        for i in range(self.out_height):\n            for j in range(self.out_width):\n                start_i = i * self.stride\n                start_j = j * self.stride\n                end_i = start_i + self.w_height\n                end_j = start_j + self.w_width\n                dx[start_i: end_i, start_j: end_j] = d_loss[i, j] / (self.w_width * self.w_height)\n        return dx\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>test</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">np.set_printoptions(precision=8, suppress=True, linewidth=120)\nx_numpy = np.random.random((1, 1, 6, 9))\nx_tensor = torch.tensor(x_numpy, requires_grad=True)\n\navg_pool_tensor = torch.nn.AvgPool2d((2, 2), 2)\navg_pool_numpy = AvgPooling2D((2, 2), stride=2)\n\nout_numpy = avg_pool_numpy(x_numpy[0, 0])\nout_tensor = avg_pool_tensor(x_tensor)\n\nd_loss_numpy = np.random.random(out_tensor.shape)\nd_loss_tensor = torch.tensor(d_loss_numpy, requires_grad=True)\nout_tensor.backward(d_loss_tensor)\n\ndx_numpy = avg_pool_numpy.backward(d_loss_numpy[0, 0])\ndx_tensor = x_tensor.grad\n# print('input \\n', x_numpy)\nprint(\"out_numpy \\n\", out_numpy)\nprint(\"out_tensor \\n\", out_tensor.data.numpy())\n\nprint(\"dx_numpy \\n\", dx_numpy)\nprint(\"dx_tensor \\n\", dx_tensor.data.numpy())<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"map\">5. mAP</h4>\n<h5 id=\"python-3\">python</h5>\n<h5 id=\"c-3\">c++</h5>\n<h4 id=\"softnms\">6. softnms</h4>\n<h5 id=\"python-4\">python</h5>\n<h6 id=\"ç‰ˆæœ¬1\">ç‰ˆæœ¬1</h6>\n<h1 id=\"soft_nmsæ“ä½œè¿™é‡Œå‡è®¾boxesæ˜¯æ— åºæœªæŒ‰scoreåšé™åºçš„æ‰€ä»¥æ¯è½®soft_nmsè¿­ä»£éƒ½éœ€è¦ç±»ä¼¼å†’æ³¡æ’åºæ“ä½œé€‰æ‹©å½“å‰top-1-bboxåšnms\">soft_nmsæ“ä½œï¼Œè¿™é‡Œå‡è®¾boxesæ˜¯æ— åº(æœªæŒ‰scoreåšé™åº)çš„ï¼Œæ‰€ä»¥æ¯è½®soft_nmsè¿­ä»£éƒ½éœ€è¦ç±»ä¼¼å†’æ³¡æ’åºæ“ä½œï¼Œé€‰æ‹©å½“å‰top-1 bboxåšNMS</h1>\n<h1 id=\"ntè®¡ç®—iouçš„é˜ˆå€¼iou-ntå¯¹åº”bboxçš„scoreæƒé‡å°±è¦é™ä½\">Ntï¼šè®¡ç®—IoUçš„é˜ˆå€¼ï¼ŒIoU &gt; Ntï¼Œå¯¹åº”bboxçš„scoreæƒé‡å°±è¦é™ä½</h1>\n<h1 id=\"thresholdé™æƒåé€šè¿‡thresholdè¿›ä¸€æ­¥å‰”é™¤ä½æƒé‡bbox\">thresholdï¼šé™æƒåé€šè¿‡thresholdè¿›ä¸€æ­¥å‰”é™¤ä½æƒé‡bbox</h1>\n<p>def cpu_soft_nms(boxes, sigma=0.5, Nt=0.3, threshold=0.001, method=0): N = boxes.shape[0] for i in range(N): maxscore = boxes[i, 4] # è·å–å½“å‰indexä¸‹çš„bbox maxpos = i</p>\n<pre><code>    tx1 = boxes[i, 0]\n    ty1 = boxes[i, 1]\n    tx2 = boxes[i, 2]\n    ty2 = boxes[i, 3]\n    ts = boxes[i, 4]\n\n    pos = i + 1  # ä¸‹é¢æ“ä½œå°±å¾ˆå¸¸è§„äº†ï¼Œæ‰¾åˆ°å½“å‰index iä¹‹åæ‰€æœ‰bboxesä¸­ï¼Œscoreæœ€å¤§çš„bboxï¼Œå¹¶å°†ä¹‹èµ‹å€¼ç»™maxscoreã€maxpos\n    while pos &lt; N:\n        if maxscore &lt; boxes[pos, 4]:\n            maxscore = boxes[pos, 4]\n            maxpos = pos\n        pos = pos + 1\n\n    # ä¸‹é¢æ“ä½œæ›´ç®€å•ï¼Œæƒ³æƒ³æˆ‘ä»¬æœ€å¼€å§‹å­¦Cè¯­è¨€ï¼Œaã€bä¸¤å˜é‡å¦‚ä½•äº¤æ¢\n    # add max box as a detection\n    boxes[i, 0] = boxes[maxpos, 0]  # maxposå†…çš„ä¿¡æ¯ï¼Œæ”¾åˆ°index iå¤„ï¼Œä¹Ÿæ˜¯å½“å‰éœ€è¦å¤„ç†çš„bbox\n    boxes[i, 1] = boxes[maxpos, 1]\n    boxes[i, 2] = boxes[maxpos, 2]\n    boxes[i, 3] = boxes[maxpos, 3]\n    boxes[i, 4] = boxes[maxpos, 4]\n\n    # swap ith box with position of max box\n    boxes[maxpos, 0] = tx1  # åˆ«å¿˜äº†tx1ä¸­å¯æ˜¯ä¿å­˜äº†boxes[i,0]å¤‡ä»½çš„\n    boxes[maxpos, 1] = ty1\n    boxes[maxpos, 2] = tx2\n    boxes[maxpos, 3] = ty2\n    boxes[maxpos, 4] = ts\n\n    tx1 = boxes[i, 0]  # æ­¤æ—¶tx1å°±ä¿å­˜çš„maxposä½ç½®çš„bboxä¿¡æ¯äº†\n    ty1 = boxes[i, 1]\n    tx2 = boxes[i, 2]\n    ty2 = boxes[i, 3]\n    ts = boxes[i, 4]\n\n    pos = i + 1\n    # NMS iterations, note that N changes if detection boxes fall below thresholdï¼ŒNå€¼æ˜¯åŠ¨æ€å˜åŒ–çš„\n    while pos &lt; N:  # å‘ååšNMSæ¯”è¾ƒ\n        x1 = boxes[pos, 0]  # å½“å‰ä½ç½®çš„bbox\n        y1 = boxes[pos, 1]\n        x2 = boxes[pos, 2]\n        y2 = boxes[pos, 3]\n        s = boxes[pos, 4]\n\n        area = (x2 - x1 + 1) * (y2 - y1 + 1)  # posä¸‹boxçš„é¢ç§¯\n        iw = (min(tx2, x2) - max(tx1, x1) + 1)  # è®¡ç®—Insectionçš„å®½iwï¼Œå¦‚æœiw &lt; 0ï¼Œè¯´æ˜æ²¡ç›¸äº¤ï¼Œå¯ä»¥ç›´æ¥å¿½ç•¥äº†\n        if iw &gt; 0:\n            ih = (min(ty2, y2) - max(ty1, y1) + 1)  # è®¡ç®—Insectionçš„å®½ihï¼Œå¦‚æœih &lt; 0ï¼Œè¯´æ˜æ²¡ç›¸äº¤ï¼Œå¯ä»¥ç›´æ¥å¿½ç•¥äº†\n            if ih &gt; 0:\n                ua = float((tx2 - tx1 + 1) * (ty2 - ty1 + 1) + area - iw * ih)  # Uçš„é¢ç§¯\n                ov = iw * ih / ua  # iou between max box and detection box\n\n                if method == 1:  # soft_nmsä¸­linearé™æƒæ“ä½œï¼Œä¸ovè´Ÿç›¸å…³\n                    if ov &gt; Nt:\n                        weight = 1 - ov\n                    else:\n                        weight = 1\n                elif method == 2:  # soft_nmsä¸­gaussiané™æƒæ“ä½œ\n                    weight = np.exp(-(ov * ov) / sigma)\n                else:  # original NMSï¼Œweight = 0å°±ç›´æ¥æŠŠscoreç½®0\n                    if ov &gt; Nt:\n                        weight = 0\n                    else:\n                        weight = 1\n\n                boxes[pos, 4] = weight * boxes[pos, 4]  # æƒé‡é‡æ–°è°ƒæ•´\n\n                # if box score falls below threshold, discard the box by swapping with last boxï¼Œupdate N\n                # å¦‚æœbboxè°ƒæ•´åçš„æƒé‡ï¼Œå·²ç»å°äºé˜ˆå€¼thresholdï¼Œé‚£ä¹ˆè¿™ä¸ªbboxå°±å¯ä»¥å¿½ç•¥äº†ï¼Œ\n                # æ“ä½œæ–¹å¼æ˜¯ç›´æ¥ç”¨æœ€åä¸€ä¸ªæœ‰æ•ˆçš„bboxæ›¿æ¢å½“å‰posä¸Šçš„bbox\n                if boxes[pos, 4] &lt; threshold:\n                    boxes[pos, 0] = boxes[N - 1, 0]\n                    boxes[pos, 1] = boxes[N - 1, 1]\n                    boxes[pos, 2] = boxes[N - 1, 2]\n                    boxes[pos, 3] = boxes[N - 1, 3]\n                    boxes[pos, 4] = boxes[N - 1, 4]\n                    N = N - 1  # N-1ä½ç½®ä¸Šçš„bboxå·²ç»èµ‹å€¼åˆ°å‰é¢äº†ï¼Œè¯¥bboxå°±å¯ä»¥å¿½ç•¥äº†ï¼›\n                    pos = pos - 1  # posä½ç½®ä¸Šå¼•å…¥äº†æ–°çš„æœ‰æ•ˆbbox(N-1)ï¼Œå°±éœ€è¦å†è®¡ç®—ä¸€éäº†\n\n        pos = pos + 1  # å½“å‰pos bboxè®¡ç®—å®Œæ¯•\n\n# æ±‚æ»¡è¶³soft_nmsç­›é€‰æ¡ä»¶çš„æ‰€æœ‰bboxæ•°é‡ï¼Œå¹¶æ‰“æ•£ä¸ºlistï¼Œä½†ä¸€ä¸ªé—®é¢˜æ˜¯ï¼šå¦‚ä½•ä¸bbox indexå¯¹åº”èµ·æ¥ï¼Ÿ\n# æ–¹å¼å¾ˆç®€å•ï¼Œbboxä¹Ÿåšäº†å¯¹åº”çš„è°ƒæ•´ã€ç­›é€‰ï¼Œbbox listä¸­top-Nå°±å¯¹åº”ç€æœ€é«˜scoreï¼Œä¸”soft-nmsç­›é€‰é€šè¿‡çš„bboxï¼Œ\n# ä¸è¿‡æ¯ä¸ªbboxçš„scoreä¹ŸåŒæ ·ç»è¿‡soft-nmsè°ƒæ•´äº†\nkeep = [i for i in range(N)]\n\nreturn keep</code></pre>\n<h6 id=\"ç‰ˆæœ¬2\">ç‰ˆæœ¬2</h6>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">def py_cpu_softnms(dets, sc, Nt=0.3, sigma=0.5, thresh=0.001, method=2):\n    \"\"\"\n    py_cpu_softnms\n    :param dets:   boexs åæ ‡çŸ©é˜µ format [y1, x1, y2, x2]\n    :param sc:     æ¯ä¸ª boxes å¯¹åº”çš„åˆ†æ•°\n    :param Nt:     iou äº¤å é—¨é™\n    :param sigma:  ä½¿ç”¨ gaussian å‡½æ•°çš„æ–¹å·®\n    :param thresh: æœ€åçš„åˆ†æ•°é—¨é™\n    :param method: ä½¿ç”¨çš„æ–¹æ³•\n    :return:       ç•™ä¸‹çš„ boxes çš„ index\n    \"\"\"\n\n    # indexes concatenate boxes with the last column\n    N = dets.shape[0]\n    indexes = np.array([np.arange(N)])\n    dets = np.concatenate((dets, indexes.T), axis=1)\n\n    # the order of boxes coordinate is [y1,x1,y2,x2]\n    y1 = dets[:, 0]\n    x1 = dets[:, 1]\n    y2 = dets[:, 2]\n    x2 = dets[:, 3]\n    scores = sc\n    areas = (x2 - x1 + 1) * (y2 - y1 + 1)\n\n    for i in range(N):\n        # intermediate parameters for later parameters exchange\n        tBD = dets[i, :].copy()\n        tscore = scores[i].copy()\n        tarea = areas[i].copy()\n        pos = i + 1\n\n        #\n        if i != N-1:\n            maxscore = np.max(scores[pos:], axis=0)\n            maxpos = np.argmax(scores[pos:], axis=0)\n        else:\n            maxscore = scores[-1]\n            maxpos = 0\n        if tscore &lt; maxscore:\n            dets[i, :] = dets[maxpos + i + 1, :]\n            dets[maxpos + i + 1, :] = tBD\n            tBD = dets[i, :]\n\n            scores[i] = scores[maxpos + i + 1]\n            scores[maxpos + i + 1] = tscore\n            tscore = scores[i]\n\n            areas[i] = areas[maxpos + i + 1]\n            areas[maxpos + i + 1] = tarea\n            tarea = areas[i]\n\n        # IoU calculate\n        xx1 = np.maximum(dets[i, 1], dets[pos:, 1])\n        yy1 = np.maximum(dets[i, 0], dets[pos:, 0])\n        xx2 = np.minimum(dets[i, 3], dets[pos:, 3])\n        yy2 = np.minimum(dets[i, 2], dets[pos:, 2])\n\n        w = np.maximum(0.0, xx2 - xx1 + 1)\n        h = np.maximum(0.0, yy2 - yy1 + 1)\n        inter = w * h\n        ovr = inter / (areas[i] + areas[pos:] - inter)\n\n        # Three methods: 1.linear 2.gaussian 3.original NMS\n        if method == 1:  # linear\n            weight = np.ones(ovr.shape)\n            weight[ovr &gt; Nt] = weight[ovr &gt; Nt] - ovr[ovr &gt; Nt]\n        elif method == 2:  # gaussian\n            weight = np.exp(-(ovr * ovr) / sigma)\n        else:  # original NMS\n            weight = np.ones(ovr.shape)\n            weight[ovr &gt; Nt] = 0\n\n        scores[pos:] = weight * scores[pos:]\n\n    # select the boxes and keep the corresponding indexes\n    inds = dets[:, 4][scores &gt; thresh]\n    keep = inds.astype(int)\n\n    return keep<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">def test():\n    # boxes and scores\n    boxes = np.array([[200, 200, 400, 400], [220, 220, 420, 420], [200, 240, 400, 440], [240, 200, 440, 400], [1, 1, 2, 2]], dtype=np.float32)\n    boxscores = np.array([0.9, 0.8, 0.7, 0.6, 0.5], dtype=np.float32)\n    index = py_cpu_softnms(boxes, boxscores, method=3)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"c-4\">c++</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n#include &lt;bits/stdc++.h&gt;\n\nnamespace nms\n{\nstruct proposal\n{\n  float score, x1, y1, x2, y2;\n};\n\ninline static bool cmp(const proposal&amp; a, const proposal&amp; b)\n{\n  return a.score &lt; b.score;\n}\n\ninline static float iou(const proposal&amp;, const proposal&amp;) __attribute__((always_inline));\n\nstatic float iou(const proposal&amp; a, const proposal&amp; b)\n{\n  auto overlap = 0.f;\n  float iw  = std::min(b.x2, a.x2) - std::max(b.x1, a.x1) + 1;\n  if (iw &gt; 0) {\n    float ih = std::min(b.y2, a.y2) - std::max(b.y1, a.y1) + 1;\n    if (ih &gt; 0) {\n      float ab = (b.x2 - b.x1 + 1) * (b.y2 - b.y1 + 1);\n      float aa = (a.x2 - a.x1 + 1) * (a.y2 - a.y1 + 1);\n      float inter = iw * ih;\n      overlap = inter / (aa + ab - inter);\n    }\n  }\n  return overlap;\n}\n\nenum class Method : uint32_t\n{\n  LINEAR = 0,\n  GAUSSIAN,\n  HARD\n};\n\nsize_t soft_nms(float* boxes,\n                int32_t* index,\n                size_t count,\n                Method method,\n                float Nt,\n                float sigma,\n                float threshold)\n{\n  std::iota(index, index + count, 0);  // np.arange()\n  auto p = reinterpret_cast&lt;proposal*&gt;(boxes);\n\n  auto N = count;\n  for (size_t i = 0; i &lt; N; ++i) {\n    auto max = std::max_element(p + i, p + N, cmp);\n    std::swap(p[i], *max);\n    std::swap(index[i], index[max - p]);\n\n    auto j      = i + 1;\n    auto weight = 0.f;\n    while (j &lt; N) {\n      auto ov = iou(p[i], p[j]);\n      switch (method) {\n        case Method::LINEAR:\n          weight = ov &gt; Nt ? 1.f - ov : 1.f;\n          break;\n        case Method::GAUSSIAN:\n          weight = std::exp(-(ov * ov) / sigma);\n          break;\n        case Method::HARD:\n          weight = ov &gt; Nt ? 0.f : 1.f;\n          break;\n      }\n      p[j].score *= weight;\n      if (p[j].score &lt; threshold) {\n        N--;\n        std::swap(p[j], p[N]);\n        std::swap(index[j], index[N]);\n        j--;\n      }\n      j++;\n    }\n  };\n\n  return N;\n}\n} /* namespace nms */\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"å®ç°one-hotç‰¹å¾\">7. å®ç°one-hotç‰¹å¾</h4>\n<h5 id=\"python-5\">python</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">one_hot_t= np.zeros_like(y)  #ç”Ÿæˆå’Œyå½¢çŠ¶ä¸€æ ·çš„å…ƒç´ ä¸ºé›¶çš„æ•°ç»„\nfor j, i in zip(range(t.size), t):\n    #æœ‰å¤šå°‘ä¸ªæ ·æœ¬å°±åº”è¯¥å¯¹åº”å¤šå°‘ä¸ªæ ‡ç­¾\n    one_hot_t[j][i] = 1      #å˜ä¸ºone-hotç±»å‹æ ‡ç­¾ï¼šjè¡¨ç¤ºæ ·æœ¬ï¼Œiè¡¨ç¤ºæ ‡ç­¾ç´¢å¼•\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"softmax\">8. softmax</h4>\n<h5 id=\"python-6\">python</h5>\n<p>ç”±äºæŒ‡æ•°å‡½æ•°çš„æ”¾å¤§ä½œç”¨è¿‡äºæ˜æ˜¾ï¼Œå¦‚æœç›´æ¥ä½¿ç”¨softmaxè®¡ç®—å…¬å¼ğ‘ ğ‘œğ‘“ğ‘¡ğ‘šğ‘ğ‘¥(ğ‘¥ğ‘–)=ğ‘’ğ‘¥ğ‘(ğ‘¥ğ‘–)/âˆ‘ğ‘’ğ‘¥ğ‘(ğ‘¥ğ‘—)è¿›è¡Œå‡½æ•°å®ç°ï¼Œå®¹æ˜“å¯¼è‡´æ•°æ®æº¢å‡º(ä¸Šæº¢)ã€‚æ‰€ä»¥æˆ‘ä»¬åœ¨å‡½æ•°å®ç°æ—¶åˆ©ç”¨å…¶æ€§è´¨ï¼šå…ˆå¯¹è¾“å…¥æ•°æ®è¿›è¡Œå¤„ç†ï¼Œä¹‹åå†åˆ©ç”¨è®¡ç®—å…¬å¼è®¡ç®—ã€‚å…·ä½“ä½¿å¾—å®ç°æ­¥éª¤ä¸ºï¼š æŸ¥æ‰¾æ¯ä¸ªå‘é‡xçš„æœ€å¤§å€¼cï¼› æ¯ä¸ªå‘é‡å‡å»å…¶æœ€å¤§å€¼c, å¾—åˆ°å‘é‡y = x-c; åˆ©ç”¨å…¬å¼è¿›è¡Œè®¡ç®—,softmax(x) = softmax(x-c) = softmax(y)</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import numpy as np\n\ndef softmax(x: np.array):\n    x_max = np.max(x, axis=-1, keepdims=True)\n    x -= x_max\n    x_exp = np.exp(x)\n    s = x_exp / np.sum(x_exp, axis=-1, keepdims=True)\n    return s\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"å„ç§æ»¤æ³¢\">9. å„ç§æ»¤æ³¢</h4>\n<h5 id=\"é©¬èµ›å…‹\">é©¬èµ›å…‹</h5>\n<p>é©¬èµ›å…‹çš„å®ç°åŸç†æ˜¯æŠŠå›¾åƒä¸ŠæŸä¸ªåƒç´ ç‚¹ä¸€å®šèŒƒå›´é‚»åŸŸå†…çš„æ‰€æœ‰ç‚¹ç”¨é‚»åŸŸå†…å·¦ä¸Šåƒç´ ç‚¹çš„é¢œè‰²ä»£æ›¿ï¼Œè¿™æ ·å¯ä»¥æ¨¡ç³Šç»†èŠ‚ï¼Œä½†æ˜¯å¯ä»¥ä¿ç•™å¤§ä½“çš„è½®å»“ã€‚ <pre class=\"line-numbers language-none\"><code class=\"language-none\">import cv2\n\ndef do_mosaic(frame, x, y, w, h, neighbor=9):\n    \"\"\"\n    :param frame: opencv frame\n    :param int x :  é©¬èµ›å…‹å·¦é¡¶ç‚¹\n    :param int y:  é©¬èµ›å…‹å³é¡¶ç‚¹\n    :param int w:  é©¬èµ›å…‹å®½\n    :param int h:  é©¬èµ›å…‹é«˜\n    :param int neighbor:  é©¬èµ›å…‹æ¯ä¸€å—çš„å®½\n    \"\"\"\n    fh, fw = frame.shape[0], frame.shape[1]\n    if (y + h &gt; fh) or (x + w &gt; fw):\n        return\n    for i in range(0, h - neighbor, neighbor):  # å…³é”®ç‚¹0 å‡å»neightbour é˜²æ­¢æº¢å‡º\n        for j in range(0, w - neighbor, neighbor):\n            rect = [j + x, i + y, neighbor, neighbor]\n            color = frame[i + y][j + x].tolist()  # å…³é”®ç‚¹1 tolist\n            left_up = (rect[0], rect[1])\n            right_down = (rect[0] + neighbor - 1, rect[1] + neighbor - 1)  # å…³é”®ç‚¹2 å‡å»ä¸€ä¸ªåƒç´ \n            cv2.rectangle(frame, left_up, right_down, color, -1)\n\n\nim = cv2.imread('test.jpg', 1)\ndo_mosaic(im, 219, 61, 460 - 219, 412 - 61)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>\n<h5 id=\"é«˜æ–¯æ»¤æ³¢\">é«˜æ–¯æ»¤æ³¢</h5>\n<p><a href=\"https://www.cnblogs.com/wojianxin/p/12498391.html\">å‡ºå¤„</a></p>\n<figure>\n<img src=\"https://img-blog.csdn.net/20171203094927312\" alt=\"äºŒç»´é«˜æ–¯å‡½æ•°\"><figcaption aria-hidden=\"true\">äºŒç»´é«˜æ–¯å‡½æ•°</figcaption>\n</figure>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import cv2\nimport numpy as np\n\ndef gaussian_filter(img, K_size=3, sigma=1.3):\n\n    if len(img.shape) == 3:\n        H, W, C = img.shape\n    else:\n        img = np.expand_dims(img, axis=-1)\n        H, W, C = img.shape\n\n    ## Zero padding\n    pad = K_size // 2\n    out = np.zeros((H + pad * 2, W + pad * 2, C), dtype=np.float)\n    out[pad: pad + H, pad: pad + W] = img.copy().astype(np.float)\n\n    ## prepare Kernel\n    K = np.zeros((K_size, K_size), dtype=np.float)\n    for x in range(-pad, -pad + K_size):\n        for y in range(-pad, -pad + K_size):\n            K[y + pad, x + pad] = np.exp( -(x ** 2 + y ** 2) / (2 * (sigma ** 2)))\n\n    K /= (2 * np.pi * sigma * sigma)\n    K /= K.sum()\n    tmp = out.copy()\n\n    # filtering\n    for y in range(H):\n        for x in range(W):\n            for c in range(C):\n                out[pad + y, pad + x, c] = np.sum(K * tmp[y: y + K_size, x: x + K_size, c])\n\n    out = np.clip(out, 0, 255)\n    out = out[pad: pad + H, pad: pad + W].astype(np.uint8)\n    return out\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"å‡å€¼æ»¤æ³¢\">å‡å€¼æ»¤æ³¢</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import numpy as np\n\n\ndef means_filter(input_image, filter_size):\n    '''\n    å‡å€¼æ»¤æ³¢å™¨\n    :param input_image: è¾“å…¥å›¾åƒ\n    :param filter_size: æ»¤æ³¢å™¨å¤§å°\n    :return: è¾“å‡ºå›¾åƒ\n\n    æ³¨ï¼šæ­¤å®ç°æ»¤æ³¢å™¨å¤§å°å¿…é¡»ä¸ºå¥‡æ•°ä¸” &gt;= 3\n    '''\n    input_image_cp = np.copy(input_image)  # è¾“å…¥å›¾åƒçš„å‰¯æœ¬\n    filter_template = np.ones((filter_size, filter_size))  # ç©ºé—´æ»¤æ³¢å™¨æ¨¡æ¿\n    pad_num = int((filter_size - 1) / 2)  # è¾“å…¥å›¾åƒéœ€è¦å¡«å……çš„å°ºå¯¸\n    input_image_cp = np.pad(input_image_cp, (pad_num, pad_num), mode=\"constant\", constant_values=0)  # å¡«å……è¾“å…¥å›¾åƒ\n    m, n = input_image_cp.shape  # è·å–å¡«å……åçš„è¾“å…¥å›¾åƒçš„å¤§å°\n    output_image = np.copy(input_image_cp)  # è¾“å‡ºå›¾åƒ\n\n    # ç©ºé—´æ»¤æ³¢\n    for i in range(pad_num, m - pad_num):\n        for j in range(pad_num, n - pad_num):\n            output_image[i, j] = np.sum(filter_template * input_image_cp[i - pad_num:i + pad_num + 1, j - pad_num:j + pad_num + 1]) / (filter_size ** 2)\n    output_image = output_image[pad_num:m - pad_num, pad_num:n - pad_num]  # è£å‰ª\n\n    return output_image<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"ä¸­å€¼æ»¤æ³¢\">ä¸­å€¼æ»¤æ³¢</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"># ä¸­å€¼æ»¤æ³¢#\nimport cv2\nimport numpy as np\n\ndef MedianFilter(img,k=3,padding=None):\n    imarray=img\n    height = imarray.shape[0]\n    width = imarray.shape[1]\n    if not padding:\n        edge = int((k - 1) / 2)\n        if height - 1 - edge &lt;= edge or width - 1 - edge &lt;= edge:\n            print(\"The parameter k is to large.\")\n            return None\n        new_arr = np.zeros((height, width), dtype=\"uint8\")\n        for i in range(edge,height-edge):\n            for j in range(edge,width-edge):\n                new_arr[i, j] = np.median(imarray[i - edge:i + edge + 1, j - edge:j + edge + 1])# è°ƒç”¨np.medianæ±‚å–ä¸­å€¼\n    return new_arr\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"kmeans\">Kmeans</h4>\n<p>https://zhuanlan.zhihu.com/p/35959301 #### ç§¯åˆ†å›¾å‡å€¼æ»¤æ³¢ https://blog.csdn.net/weixin_40647819/article/details/88775598</p>\n","text":"1. IOU python def bb_intersection_over_union(boxA, boxB): boxA = [int(x) for x in boxA] boxB = [int(x) for x in boxB] xA = max(boxA[0], boxB...","link":"","photos":[],"count_time":{"symbolsCount":"25k","symbolsTime":"23 mins."},"categories":[],"tags":[{"name":"interview summary","slug":"interview-summary","count":2,"path":"api/tags/interview-summary.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#iou\"><span class=\"toc-text\">1. IOU</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#python\"><span class=\"toc-text\">python</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#c\"><span class=\"toc-text\">c++</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#nms\"><span class=\"toc-text\">2. NMS</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#python-1\"><span class=\"toc-text\">python</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#c-1\"><span class=\"toc-text\">c++</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8D%B7%E7%A7%AF\"><span class=\"toc-text\">3. å·ç§¯</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#python-2\"><span class=\"toc-text\">python</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#c-2\"><span class=\"toc-text\">c++</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#pooling\"><span class=\"toc-text\">4. Pooling</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#maxpooling\"><span class=\"toc-text\">maxpooling</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E7%89%88%E6%9C%AC1%E7%AE%80%E5%8D%95%E7%89%88\"><span class=\"toc-text\">ç‰ˆæœ¬1(ç®€å•ç‰ˆ)</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E7%89%88%E6%9C%AC2%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD\"><span class=\"toc-text\">ç‰ˆæœ¬2(åå‘ä¼ æ’­)</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#avg-pooling\"><span class=\"toc-text\">avg-pooling</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E7%89%88%E6%9C%AC1%E7%AE%80%E5%8D%95%E7%89%88-1\"><span class=\"toc-text\">ç‰ˆæœ¬1(ç®€å•ç‰ˆ)</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E7%89%88%E6%9C%AC2%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD-1\"><span class=\"toc-text\">ç‰ˆæœ¬2(åå‘ä¼ æ’­)</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#map\"><span class=\"toc-text\">5. mAP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#python-3\"><span class=\"toc-text\">python</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#c-3\"><span class=\"toc-text\">c++</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#softnms\"><span class=\"toc-text\">6. softnms</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#python-4\"><span class=\"toc-text\">python</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E7%89%88%E6%9C%AC1\"><span class=\"toc-text\">ç‰ˆæœ¬1</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#soft_nms%E6%93%8D%E4%BD%9C%E8%BF%99%E9%87%8C%E5%81%87%E8%AE%BEboxes%E6%98%AF%E6%97%A0%E5%BA%8F%E6%9C%AA%E6%8C%89score%E5%81%9A%E9%99%8D%E5%BA%8F%E7%9A%84%E6%89%80%E4%BB%A5%E6%AF%8F%E8%BD%AEsoft_nms%E8%BF%AD%E4%BB%A3%E9%83%BD%E9%9C%80%E8%A6%81%E7%B1%BB%E4%BC%BC%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C%E9%80%89%E6%8B%A9%E5%BD%93%E5%89%8Dtop-1-bbox%E5%81%9Anms\"><span class=\"toc-text\">soft_nmsæ“ä½œï¼Œè¿™é‡Œå‡è®¾boxesæ˜¯æ— åº(æœªæŒ‰scoreåšé™åº)çš„ï¼Œæ‰€ä»¥æ¯è½®soft_nmsè¿­ä»£éƒ½éœ€è¦ç±»ä¼¼å†’æ³¡æ’åºæ“ä½œï¼Œé€‰æ‹©å½“å‰top-1 bboxåšNMS</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#nt%E8%AE%A1%E7%AE%97iou%E7%9A%84%E9%98%88%E5%80%BCiou-nt%E5%AF%B9%E5%BA%94bbox%E7%9A%84score%E6%9D%83%E9%87%8D%E5%B0%B1%E8%A6%81%E9%99%8D%E4%BD%8E\"><span class=\"toc-text\">Ntï¼šè®¡ç®—IoUçš„é˜ˆå€¼ï¼ŒIoU &gt; Ntï¼Œå¯¹åº”bboxçš„scoreæƒé‡å°±è¦é™ä½</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#threshold%E9%99%8D%E6%9D%83%E5%90%8E%E9%80%9A%E8%BF%87threshold%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%89%94%E9%99%A4%E4%BD%8E%E6%9D%83%E9%87%8Dbbox\"><span class=\"toc-text\">thresholdï¼šé™æƒåé€šè¿‡thresholdè¿›ä¸€æ­¥å‰”é™¤ä½æƒé‡bbox</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E7%89%88%E6%9C%AC2\"><span class=\"toc-text\">ç‰ˆæœ¬2</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#c-4\"><span class=\"toc-text\">c++</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0one-hot%E7%89%B9%E5%BE%81\"><span class=\"toc-text\">7. å®ç°one-hotç‰¹å¾</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#python-5\"><span class=\"toc-text\">python</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#softmax\"><span class=\"toc-text\">8. softmax</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#python-6\"><span class=\"toc-text\">python</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%90%84%E7%A7%8D%E6%BB%A4%E6%B3%A2\"><span class=\"toc-text\">9. å„ç§æ»¤æ³¢</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%A9%AC%E8%B5%9B%E5%85%8B\"><span class=\"toc-text\">é©¬èµ›å…‹</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%AB%98%E6%96%AF%E6%BB%A4%E6%B3%A2\"><span class=\"toc-text\">é«˜æ–¯æ»¤æ³¢</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2\"><span class=\"toc-text\">å‡å€¼æ»¤æ³¢</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2\"><span class=\"toc-text\">ä¸­å€¼æ»¤æ³¢</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#kmeans\"><span class=\"toc-text\">Kmeans</span></a></li></ol>","author":{"name":"Hulk Wang","slug":"blog-author","avatar":"/images/avatar_small.jpg","link":"https://github.com/TalkUHulk","description":"å­¦ä¹ ã€è®°å½•ã€æ€»ç»“<br />killæ‹–å»¶ç—‡<br /> ä¸ç”Ÿäº§çŸ¥è¯†ï¼Œåªæ˜¯çŸ¥è¯†çš„æ¬è¿å·¥<br /> <img src=\"/images/funny.gif\" height=\"240\" width=\"360\"/>","socials":{"github":"https://github.com/TalkUHulk","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/311127773","zhihu":"https://www.zhihu.com/people/MisterAntebellum","csdn":"https://blog.csdn.net/hyqwmxsh","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"æ— ç›‘ç£å¯¹æ¯”å­¦ä¹ (Contrastive LearningOC)","uid":"84b6109cde20e5bfc02c6af7734d88cb","slug":"æ— ç›‘ç£å¯¹æ¯”å­¦ä¹ -Contrastive-LearningOC","date":"2021-11-02T03:39:11.000Z","updated":"2021-11-03T11:00:42.159Z","comments":true,"path":"api/articles/æ— ç›‘ç£å¯¹æ¯”å­¦ä¹ -Contrastive-LearningOC.json","keywords":null,"cover":"/images/contrastive/cl.jpg","text":" æ¨èé˜…è¯» å¯¹æ¯”å­¦ä¹  åŸç†: è¾“å…¥Nä¸ªå›¾ç‰‡ï¼Œç”¨ä¸åŒçš„æ•°æ®å¢å¼ºæ–¹æ³•ä¸ºæ¯ä¸ªå›¾ç‰‡ç”Ÿæˆä¸¤ä¸ªviewï¼Œåˆ†åˆ«å¯¹å®ƒä»¬ç¼–ç å¾—åˆ°yå’Œy'ã€‚æˆ‘ä»¬å¯¹ä¸Šä¸‹ä¸¤æ‰¹è¡¨ç¤ºä¸¤ä¸¤è®¡ç®—cosineï¼Œå¾—åˆ°NxNçš„çŸ©é˜µï¼Œæ¯ä¸€è¡Œçš„å¯¹è§’çº¿ä½ç½®ä»£è¡¨yå’Œy'çš„ç›¸ä¼¼åº¦ï¼Œå…¶ä½™ä»£è¡¨yå’ŒN-1ä¸ªè´Ÿä¾‹çš„ç›¸ä¼¼åº¦ã€‚ å¯¹æ¯ä¸€è¡Œåšsoftmaxåˆ†...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"work summary","slug":"work-summary","count":5,"path":"api/tags/work-summary.json"}],"author":{"name":"Hulk Wang","slug":"blog-author","avatar":"/images/avatar_small.jpg","link":"https://github.com/TalkUHulk","description":"å­¦ä¹ ã€è®°å½•ã€æ€»ç»“<br />killæ‹–å»¶ç—‡<br /> ä¸ç”Ÿäº§çŸ¥è¯†ï¼Œåªæ˜¯çŸ¥è¯†çš„æ¬è¿å·¥<br /> <img src=\"/images/funny.gif\" height=\"240\" width=\"360\"/>","socials":{"github":"https://github.com/TalkUHulk","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/311127773","zhihu":"https://www.zhihu.com/people/MisterAntebellum","csdn":"https://blog.csdn.net/hyqwmxsh","juejin":"","customs":{}}}},"next_post":{"title":"CVé¢è¯•åŸºç¡€æ€»ç»“","uid":"2d84f3892209cec11720cffbf464a897","slug":"CVé¢è¯•åŸºç¡€æ€»ç»“","date":"2021-10-12T07:57:22.000Z","updated":"2021-11-11T03:50:39.415Z","comments":true,"path":"api/articles/CVé¢è¯•åŸºç¡€æ€»ç»“.json","keywords":null,"cover":"/images/interview/FID_dis.jpg","text":"1. è¯„æµ‹æŒ‡æ ‡ 1.1 åŸºæœ¬æ¦‚å¿µ 1.1.1 TP TN FP FN T-Ture;F-False è¡¨ç¤ºé¢„æµ‹ç»“æœçš„æ­£ç¡®æ€§ï¼ŒTè¡¨ç¤ºé¢„æµ‹æ­£ç¡®ï¼ŒFè¡¨ç¤ºé¢„æµ‹é”™è¯¯ï¼› P-positive;N-negative è¡¨ç¤ºé¢„æµ‹çš„æ­£è´Ÿæ€§ï¼ŒPè¡¨ç¤ºé¢„æµ‹ä¸ºæ­£æ ·æœ¬ï¼ŒNè¡¨ç¤ºé¢„æµ‹ä¸ºè´Ÿæ ·æœ¬ï¼› --- --- TP...","link":"","photos":[],"count_time":{"symbolsCount":"48k","symbolsTime":"44 mins."},"categories":[],"tags":[{"name":"interview summary","slug":"interview-summary","count":2,"path":"api/tags/interview-summary.json"}],"author":{"name":"Hulk Wang","slug":"blog-author","avatar":"/images/avatar_small.jpg","link":"https://github.com/TalkUHulk","description":"å­¦ä¹ ã€è®°å½•ã€æ€»ç»“<br />killæ‹–å»¶ç—‡<br /> ä¸ç”Ÿäº§çŸ¥è¯†ï¼Œåªæ˜¯çŸ¥è¯†çš„æ¬è¿å·¥<br /> <img src=\"/images/funny.gif\" height=\"240\" width=\"360\"/>","socials":{"github":"https://github.com/TalkUHulk","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/311127773","zhihu":"https://www.zhihu.com/people/MisterAntebellum","csdn":"https://blog.csdn.net/hyqwmxsh","juejin":"","customs":{}}}}}